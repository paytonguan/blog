---
title: 黑苹果的安装与配置
categories: Mac
abbrlink: Hackintosh-Installation
date: 2019-11-26 14:24:16
tags:
---

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9bt5qlkq5j31lv0u0kii.jpg)

本文以macOS Mojave为例进行说明，包含内容较多，主要适合较新主板的安装。

<!-- more -->

# 虚拟机安装

## 通过Vmware

适用于Lion及以上的系统。对于Lion以上的系统，可直接挂载ISO安装。

安装Vmware Workstation 11/12/14/15，或Vmware Workstation Player 7/12/14/15。Vmware Workstation Player 15下载链接如下。

```
http://www.pc9.com/pc/info-3974.html
```

安装完成后，打开任务管理器，切换到服务选项卡，停止所有与VM有关的服务。

通过以下链接下载Vmware虚拟机苹果破解补丁unlocker，解压后右键以管理员身份运行win-install，完成虚拟机对macOS系统限制的破解。

```
https://github.com/paolo-projects/auto-unlocker
https://github.com/DrDonk/unlocker

// 不可用
https://github.com/theJaxon/unlocker
```

若过程提示错误，可能是由于文件下载不成功。

```
https://softwareupdate.vmware.com/cds/vmw-desktop/fusion/
```

打开以上链接，选择当前最大版本后下载以下两个文件，放置到unlocker/tools。重新运行程序，可能会出现`A backup folder has been found. Do you wish uninstall the previous patch?.....`的提示，输入Y即可。

```
com.vmware.fusion.zip.tar\com.vmware.fusion.zip\payload\VMware Fusion.app\Contents\Library\isoimages\darwin.iso
com.vmware.fusion.zip.tar\com.vmware.fusion.zip\payload\VMware Fusion.app\Contents\Library\isoimages\darwinPre15.iso
```

打开Vmware Workstation Player，创建新虚拟机，系统选择Mac OS X，安装光盘选择Mac OS X的iso或cdr镜像文件，注意不能是dmg格式。cdr格式的可用镜像示例如下。

```
链接 / https://pan.baidu.com/s/13rD1YbYwSKSDVhIxoUVxHw
提取码 / 4nii
```

创建并完成虚拟机内Mac的安装，注意用户密码不能为空。安装完成后，在虚拟机菜单上点击`安装Vmware Tools for Mac`，即可使Mac满屏显示。

点击虚拟机选项-共享文件夹，勾选`总是启用`并设置好共享文件夹，即可完成Windows和Mac的文件互通。

<details>
<summary>【旧版】对于Snow Leopard及以下系统</summary>

不能直接挂载ISO，否则会出现`客户端系统不是Mac OS X Server。`的提示。可通过Clover作为中介。

插入带有Clover引导的U盘，在虚拟机设置好安装光盘，但不要连接到虚拟机。启动虚拟机并将U盘连接到虚拟机，然后重启，直至U盘被引导。然后连接CD，此时Clover识别到光驱，将自动出现相关引导项，点击即可。

如果dmg无法安装，可通过UltraISO转换为ISO镜像文件。
</details>

## 通过VirtualBox

下载Clover的Bootable ISO。新建虚拟机，类型选择macOSX，版本选择Mac镜像对应的版本。新建完成后编辑设置，点击存储，在`控制器: SATA`下点击光盘的+号，添加两个光驱，一个是Clover引导器（SATA端口1），一个是系统安装盘（SATA端口0）。按照顺序，SATA端口1优先级高于SATA端口0。完成后启动虚拟机，通过Clover引导即可。

## 通过KVM

通过Linux下的KVM，可安装Mac到虚拟机并通过直通的方式，实现几乎原生的体验。主板需支持虚拟化，对于Intel为Vt-d和Vt-x，对于AMD为SVM（Secure Virtual Machine）即安全虚拟机。该方式对硬件厂商无硬性要求。若要直通，需有一张独立显卡和一个可热插拔的USB控制器。

首先需要安装Linux，可选用Manjaro，下载链接如下。

```
https://manjaro.org/
```

完成后打开终端并输入以下命令。

```
sudo apt-get install qemu python python-pip git virt-manager
pip install click request
git clone https://github.com/foxlet/macOS-Simple-KVM.git
cd macOS-Simple-KVM

# 执行本句后默认下载Catalina镜像，可通过./jumpstart --high-sierra/--mojave/--catalina选择版本
./jumpstart.sh

qemu-img create -f qcow2 MyDisk.qcow2 64G
```

在basic.sh的末尾添加以下两行。

```
    -drive id=SystemDisk,if=none,file=MyDisk.qcow2 \
    -device ide-hd,bus=sata.4,drive=SystemDisk \
```

同时可修改basic.sh中的第23行以修改MAC地址，避免Apple ID问题。MAC地址可通过以下命令生成。

```
openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/:$//'
```

也可修改`-m 2G \`以修改内存大小，修改`-smp 4,cores=2 \`为`-smp cpus=X,cores=X,threads=1,sockets=1 \`以修改CPU核数。

然后通过以下命令运行脚本即可启动Mac安装。

```
./basic.sh
```

完成后输入以下命令以将配置导入到Virt-Manager，然后将MyDisk.qcow2添加为虚拟硬盘。注意不要通过Virt-Manager修改虚拟机参数，可通过`virsh edit`修改，但不要修改CPU型号。

```
sudo ./make.sh --add
```

<details>
<summary>【过时】旧方法</summary>

需要的依赖有libvirt、QEMU、OVMF、Virtual Machine Manager。

打开终端并输入以下命令以启用KVM服务。

```
systemctl enable libvirtd
systemctl start libvirtd
```

输入以下命令克隆Hackintosh-KVM仓库。

```
https://github.com/PassthroughPOST/Hackintosh-KVM
```

在以下仓库下载OVMF_CODE.fd和OVMF_VARS.fd，并放置到刚才的目录下。

```
https://github.com/kholia/OSX-KVM
```

打开Example-XML-Files，复制对应平台的配置文件到上一层目录，并更名为Hackintosh.xml。

打开后删除所有的"value=-object"以及相连的"input"行，然后修改loader和nvram为刚才下载的两个文件OVMF_CODE.fd和OVMF_VARS.fd的路径。

在Mac环境下载High Sierra安装镜像，并通过脚本中的create_iso_highsierra.sh创建安装ISO，具体命令如下。

```
cd [脚本所在目录]
chmod +x ./create_iso_highsierra.sh
./create_iso_highsierra.sh
```

将制作好的ISO拷贝到Linux。在终端输入以下命令启用虚拟机。

```
cd Hackintosh-KVM
sudo virsh define Hackintosh.xml
```

打开Virtual Machine Manager，即可看到刚才启用的虚拟机。点击虚拟机设置，添加虚拟硬盘并指向Hackintosh-KVM文件夹中的clover.qcow2文件，添加虚拟光驱并指向制作好的安装ISO。启动即可开始安装Mac。安装完成后需要将Clover安装到硬盘中。
</details>

在Virtual Machine Manager中修改虚拟机设置，点击Add Hareware-PCI Host Device即可直通显卡和USB控制器。完成直通设置后，需要修改grub的启动参数以告诉Linux需要直通的硬件。具体而言，打开/etc/default/grub，修改如下。

```
# amd_iommu=on表示开启设备IOMMU分组，可输入dmesg | grep -i iommu检查IOMMU是否已正确分组，若不正确则需要更换插槽
# vfio-pci.ids=1b81,10de:10f0为要直通的设备，需要更换为直通的设备ID，可通过lspci -nn查看
GRUB_CMDLINE_LINUX_DEFAULT="quiet amd_iommu=on vfio-pci.ids=1b81,10de:10f0"
GRUB_CMDLINE_LINUX="amd_iommu=on vfio-pci.ids=1b81,10de:10f0"
```

# 硬盘安装

## 记录硬件配置

在Windows下，右键点击此电脑，选择管理-设备管理器，得到设备清单。在某设备上点击属性-详细信息，在属性下拉栏选择硬件ID，记录下VID和PID。VID即Vendor ID，指供应商ID，在Windows下以`VID_`显示。PID即Device ID，指设备ID，在Windows下以`PID_`显示。

可通过以下链接查询设备名称与PID的关系。

```
# Intel
http://pci-ids.ucw.cz/read/PC/8086

# AMD
http://pci-ids.ucw.cz/read/PC/1022

# Nvidia
http://pci-ids.ucw.cz/read/PC/10de
```

Mac对Intel CPU基本兼容，对AMD CPU需要进一步处理。本教程仅讨论Intel CPU的情况。

对于笔记本，主要记录显卡、声卡、网卡、键盘、触控板和蓝牙的型号。以本机为例，型号为华硕FL8000U，硬件基本信息如下。需要注意的是，BIOS类型应为UEFI。

|          |               型号               | Device ID | Vendor ID |
|----------|----------------------------------|-----------|-----------|
| CPU      | Intel Core i7-8550U（Kaby-Lake） | /         | /         |
| 核心显卡 | Intel UHD Graphics 620           | 5917      | 8086      |
| 独立显卡 | NVIDIA GeForce 940MX             | 134D      | 10DE      |
| 声卡     | Realtek ALC 294                  | 0294      | 10EC      |
| 有线网卡 | Realtek RTL8111                  | /         | /         |
| 无线网卡 | Atheros AR9565                   | 0036      | 168C      |
| 键盘     | PS2键盘                          | /         | /         |
| 触摸板   | I2C触摸板                        | /         | /         |
| 蓝牙     | Atheros Bluetooth 4.0            | 3018      | 04CA      |

## 安装包下载

### 通过链接

可通过黑果小兵的博客下载，镜像带引导。

```
https://blog.daliansky.net/categories/%E4%B8%8B%E8%BD%BD/%E9%95%9C%E5%83%8F/
```

也可在Mac下也可通过以下链接，通过App Store下载。

```
https://apps.apple.com/cn/app/macos-mojave/id1398502828?mt=12
```

也可通过以下链接。

```
链接 / https://cloud.189.cn/t/FFvIV3aeQZRz
提取码 / ps0j
```

### 通过macrecovery

注意，该方法只可获取恢复分区，安装系统时需要互联网连接。

以Windows为例，下载OpenCore，链接如下。

```
https://github.com/acidanthera/OpenCorePkg
```

解压后打开命令提示符，路径切换到解压文件夹内的Utilities/macrecovery，然后通过以下命令进行下载。

```
# Lion
python macrecovery.py -b Mac-2E6FAB96566FE58C -m 00000000000F25Y00 download
python macrecovery.py -b Mac-C3EC7CD22292981F -m 00000000000F0HM00 download

# Mountain Lion
python macrecovery.py -b Mac-7DF2A3B5E5D671ED -m 00000000000F65100 download

# Mavericks
python macrecovery.py -b Mac-F60DEB81FF30ACF6 -m 00000000000FNN100 download

# Yosemite
python macrecovery.py -b Mac-E43C1C25D4880AD6 -m 00000000000GDVW00 download

# El Capitan
python macrecovery.py -b Mac-FFE5EF870D7BA81A -m 00000000000GQRX00 download

# Sierra
python macrecovery.py -b Mac-77F17D7DA9285301 -m 00000000000J0DX00 download

# High Sierra
python macrecovery.py -b Mac-7BA5B2D9E42DDD94 -m 00000000000J80300 download
python macrecovery.py -b Mac-BE088AF8C5EB4FA2 -m 00000000000J80300 download

# Mojave
python macrecovery.py -b Mac-7BA5B2DFE22DDD8C -m 00000000000KXPG00 download

# Catalina
python macrecovery.py -b Mac-00BE6ED71E35EB86 -m 00000000000000000 download

# Big Sur
python macrecovery.py -b Mac-E43C1C25D4880AD6 -m 00000000000000000 download
```

完成后将USB格式化为GUID分区表下的FAT32。在USB根目录新建文件夹，名称为`com.apple.recovery.boot`，并将下载好的BaseSystem/RecoveryImage文件放入文件夹内。

### 通过GibMacOS

对于10.13及以上系统，可在Mac环境下通过GibMacOS下载原版镜像，注意不带引导。运行gibMacOS.command即可，链接如下。

```
https://github.com/corpnewt/gibMacOS
```

对于Big Sur，下载后在Mac下打开installAssistant.pkg，安装到当前系统盘，即可在应用程序中找到安装包程序。对于Catalina及更早版本，则应当运行BuildmacOSInstallApp.command以得到安装包，然后将安装包拖入应用程序文件夹。

### 通过InstallInstallMacOS

适用于在Mac环境下下载，打开终端并输入以下命令即可得到dmg文件。

```
mkdir ~/macOS-installer && cd ~/macOS-installer && curl -O https://raw.githubusercontent.com/munki/macadmin-scripts/main/installinstallmacos.py && sudo python installinstallmacos.py
```

## 硬盘分区

由于macOS只能以EFI方式引导，因此需确保分区表为GPT格式。

可在Windows下打开DiskGenius，确认分区表为GUID格式，若不是，则在硬盘上单击右键，选择`转换分区表类型为GUID格式`。

确保硬盘有一个200-300M的EFI分区，若没有则需要新建，一般新建到硬盘最前部。提前备份EFI内的文件至U盘，防止安装Mac时引导丢失。为Mac的安装划出50G以上的分区，格式化为APFS。

若用Mac进行格式化，则格式化为GUID分区表时会自动生成一个200MB的EFI分区。

## 引导器下载

黑苹果需要特殊的引导器进行引导。此处使用Clover，链接如下。

```
# 普通版
https://github.com/Dids/clover-builder/releases
https://sourceforge.net/projects/cloverefiboot/

# 特别版
https://github.com/chris1111/CloverBootloader/releases
https://drive.google.com/drive/folders/0B661P9Kp9bPAdUViMVFYRW9KWFE
```

建议下载pkg或ISO版本，其中对于ISO版本，可用解压软件打开，提取Clover启动所需要的完整EFI文件夹，以便于后续安装。该文件夹的目录层级如下。

```
└── EFI
   ├── Boot
   └── CLOVER
        ├── ACPI
        ├── drivers
        ├── ...
        ├── CLOVERX64.efi
        └── config.plist
```

## 安装盘制作

此处以Majove 10.14.3为例。插入容量大于8G的U盘，提前备份好U盘资料。

### 对于从黑果小兵下载

若为Windows，且下载的镜像为带引导的dmg格式，则以管理员身份打开TransMac，在插入的U盘上点击右键，选择Restore with Disk Image，点击Yes以抹掉资料，选择dmg镜像，等待写入完成。也可通过Etcher完成以上操作。

由于黑果小兵的安装盘已带引导器，故可以直接进行安装步骤。

### 对于从macrecovery下载

下载完成后将获得BaseSystem或RecoveryImage文件。将USB格式化为FAT32，在根目录新建名为com.apple.recovery.boot的文件夹并复制下载内容至该文件夹，注意.dmg和.chunklist文件都要复制。然后复制从Clover提取的EFI文件夹到根目录，保持与com.apple.recovery.boot文件夹同级。

### 对于从GibMacOS下载

若为Mac，且获取的是不带引导的系统app安装包，则先将USB进行分区，分区表为GUID，创建一个大小为200-300MB的EFI分区，剩余空间则用于安装程序。

打开终端并输入以下命令，注意将MyVolume替换为USB磁盘名称。完成后复制从Clover提取的EFI文件夹到EFI磁盘。

```
# 以Mojave为例
sudo /Applications/Install\ macOS\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume
```

若为Windows，则通过MakeInstall.bat进行制作，注意该脚本将默认创建MBR引导。

<details>
<summary>【进阶】用BaseSystem.dmg制作安装盘</summary>

不适用于High Sierra及以上系统。

BaseSystem.dmg可在安装包上点击右键，选择显示包内容，然后进入/Contents/Shared Support/即可找到。复制到桌面后，打开终端并输入以下命令以制作。

```
# disk1s2为USB设备路径，按照实际情况更改
sudo asr restore -source ~/Desktop/BaseSystem.dmg -target /dev/disk1s2 --erase
```
</details>

## BIOS设置

### 全局设置

有AHCI的均选`AHCI`，开启支持UEFI启动。

|                 选项                | 本机BIOS地址 | 设定值 |      设置      |                             说明                            |
|-------------------------------------|--------------|--------|----------------|-------------------------------------------------------------|
| Fast Boot                           | 0xF7A        | 0x0    | Disabled       | 快速启动                                                    |
| Secure Boot                         |              |        | Disabled       | 安全启动                                                    |
| CFG Lock                            | 0x527        | 0x0    | Disabled       | CFG锁（MSR 0xE2写入保护）                                   |
| Vt-d                                | 0x7EC        | 0x0    | Disabled       | 直接I/O访问的VT虚拟化技术                                   |
| CSM                                 | 0x1032       | 0x0    | Disabled       | 兼容性支持模块（如果看到乱码则启用）                        |
| Intel SGX                           | 0x5DC        | 0x0    | Disabled       | Intel架构新扩展                                             |
| IO Serial Port                      |              |        | Disabled       | 串行端口，打开可能会引起睡眠死机问题                        |
| LAN/WLAN switching                  |              |        | Disabled       | LAN/WLAN切换                                                |
| Extended Idle Power States          |              |        | Disabled       | 扩展空闲电源状态                                            |
| Wake on LAN/WLAN/WWAN               |              |        | Disabled       | LAN/WLAN/WWAN唤醒                                           |
| Wake on USB                         |              |        | Disabled       | USB唤醒                                                     |
| Firewire/IEEE 1394                  |              |        | Disabled       | 火线/IEEE 1394设备                                          |
| USB 3.0                             |              |        | Disabled       | 安装好系统后可以开启                                        |
| TMP/Security Chips/Security modules |              |        | Disabled       | 安全模块                                                    |
| VT-x                                | /            | /      | Enabled        | 英特尔虚拟化技术                                            |
| Above 4G decoding                   | 0x7ED        | 0x1    | Enabled        | 大于4G地址空间解码                                          |
| Hyper Threading                     | 0x4F0        | 0x1    | Enabled        | 处理器超线程                                                |
| Execute Disable Bit                 | 0x4E9        | 0x1    | Enabled        | 执行禁止位                                                  |
| EHCI Hand-off                       | 0x2          | 0x1    | Enabled        | 接手EHCI控制                                                |
| XHCI Hand-off                       | 0x1B         | 0x1    | Enabled        | 接手XHCI控制                                                |
| USB Hand-off                        |              |        | Enabled        | 接手USB控制（打开后则无需ReleaseUsbOwnership/Fixownership） |
| Launch Hotkeys without Fn keypress  |              |        | Enabled        | 对于Skylake和KabyLake平台                                   |
| USB Legacy support                  |              |        | Enable         | 旧版USB支持                                                 |
| OS type                             | /            | /      | Windows 8.1/10 | 操作系统类型Windows 8.1/10                                  |
| Controller Mode                     |              |        | AHCI mode      | 硬盘模式                                                    |
| Thunderbolt Support                 |              |        | Disabled       |                                                             |
| Intel Platform Trust                |              |        | Disabled       |                                                             |
| Portable Device Charging Mode       |              |        | Disabled       |                                                             |
| Thunderbolt Security Level          |              |        | Legacy Mode    |                                                             |
| HPET Support                        |              |        | Enabled        |                                                             |
| HPET Mode                           |              |        | 64-bit mode    |                                                             |
| ACPI Suspend Type                   |              |        | S3(STR)        |                                                             |
| Parallel Port                       |              |        | Disabled       |                                                             |
| Serial Port                         |              |        | Disabled       |                                                             |

### 显卡设置

若有Nvidia/AMD的显卡，则主显示器应设置为PEG或PCIE，并禁用与Intel显卡有关的选项（Hybrid Graphics/Dual Graphics/DVMT size等）。

若有Intel的显卡，则将DVMT设置为64MB或更大，将MAX TOLUD设置为Dynamic。

## 正式安装

BIOS中启动顺序把UEFI启动的U盘设为第一，在弹出的Clover界面选择Boot OS X Install from Install macOS Majove，稍等片刻进入安装界面。

<details>
<summary>【注意】关于安全启动</summary>

不要打开安全启动进行安装，因为Mac将使用安装程序生成的随机值进行个性化设置。由于随机值不同，将无法再用安全启动引导到系统。
</details>

在macOS实用工具中选择`磁盘工具`，点击左侧按钮选择`显示所有设备`，选择之前分好的Mac安装盘，点击抹掉，并选择格式为APFS。返回安装界面，选择刚才格式化好的盘进行安装，等待安装完成。

重启时需继续从U盘启动，Clover界面中选择macOS的安装盘，进入欢迎界面后注意用户密码不能为空且跳过iCloud设置。正常进入黑苹果桌面后不要登录iCloud、iMessage、FaceTime。

若在跑代码的过程中发生错误，则根据常见问题进行排除。

## 本地引导

### Clover安装

在Mac下打开Clover的pkg安装包，同意协议后点击自定，勾选安装在Clover到EFI分区、UEFI Drivers。

安装完成后使用Clover Configurator挂载EFI分区，并打开EFI/CLOVER/kexts，只留Others文件夹，其余删除。打开Others文件夹，只留VirtualSMC.kext、WhatEverGreen.kext和Lilu.kext。

然后打开EFI/CLOVER/DRIVER64UEFI，删除SMCHelper-64.efi并复制VirtualSMC.efi到此目录下。

目录层级如下。

```
├── ACPI
├── CLOVERX64.efi
├── config.plist
├── drivers
│   └── UEFI
│       ├── ApfsDriverLoader.efi
│       ├── AudioDxe.efi
│       ├── DataHubDxe.efi
│       ├── FSInject.efi
│       ├── HFSPlus.efi
│       ├── OpenRuntime.efi
│       └── VirtualSmc.efi
├── kexts
    └── Other
        ├── Lilu.kext
        ├── VirtualSMC.kext
        └── WhateverGreen.kext
```

### Clover配置

用Clover Configurator打开config.plist，按下列设置进行修改。

#### ACPI

将Fixs下所有选项取消勾选（1和2两个页面的选项都要取消），并添加以下更名补丁。

```
Comment: change _DSM to XDSM
Find: 5F44534D
Replace: 5844534D
```

#### Boot

Arguments下勾选Verbose（-v）、nv_disable=1、dart=0，其余不勾选。

#### Grpahics

取消勾选Inject Intel、Inject EDID。

#### Devices

在Audio的Inject下拉菜单选择No，把下方Arbitrary、Properties和Add Properties所有内容删掉。

### 进入系统

退出Clover Configurator，保存更改后拔出U盘并重启，在BIOS下应当多出一项UEFI OS，进入后选择macOS安装盘启动。此时已完成Clover引导器的安装，可以脱离U盘引导。

若Windows引导丢失，将备份好的EFI/BOOT中的Microsoft文件夹复制到EFI分区中的EFI/BOOT，与Clover文件夹同级即可。

## 驱动修补

Mac的驱动以Kernel Extensions（kexts）形式存在。系统的kexts存放于/System/Library/Extentions（SLE）或/Library/Extentions（LE），其中SLE为系统kexts的主要放置路径，LE为系统拓展kexts放置路径。kexts内部的dsYM是签名文件，仅用于调试目的。

一般不建议修改SLE或LE目录。若需将驱动装入SLE或LE，可通过Kext Utility（在Catalina下需先解锁系统分区）或Hackintool。以Hackintool为例，在Hackintool的`工具`选项卡下点击下方的小屋按钮即可。

### 显卡

默认情况下，Mac对没有提供驱动程序的任何GPU都将运行非常基本的驱动程序，称为VESA驱动程序，提供了最少的显示输出，但在该情况下无法与这些设备正确交互。为了解决这个问题，需要让Mac认为显卡是一个通用的PCIe设备，或完全关闭显卡。

注意，VGA在Mac中不可使用。驱动显卡前确保kexts文件夹内有Lilu.kext和WhateverGreen.kext。

#### 选择显卡

在DSDT的PCI0设备目录下，Intel显卡拥有关键字`Name (_ADR, 0x00010000)`。Mac原生支持Intel显卡，但需要进行缓冲帧修补。

对于笔记本而言，如果独显不与核显绑定，即独显本身可以独立工作，则不需要屏蔽独显，可从BIOS层面关闭核显，并寻找独显驱动。该情况能够存在的必要条件是MUX芯片存在，但大多数笔记本电脑都没有该芯片。包含该芯片的笔记本列表可参照以下表格。

|              设备             |          CPU          |                                                dGPU直通                                                |                                              iGPU直通                                              |                                eGPU直通                                |                               备注                               |
|-------------------------------|-----------------------|--------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|------------------------------------------------------------------------|------------------------------------------------------------------|
| Razer Blade 15 (2018 Basic)   | Intel Core i7-8750H   | GTX 1060 Mobile with Max-Q design (6GB)</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下大概能工作 | Intel UHD Graphics 630</br>Windows下大概能工作；Linux下大概能工作                                  | GTX 970</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下大概能工作 | 支持TB3 eGPU                                                     |
| Gigabyte P35X v4              | Intel Core i7-5700HQ  | GTX 980M (8GB)</br>Windows下工作；Linux下未知                                                          | Intel HD Graphics 5600</br>Windows下工作；Linux下未知                                              |                                                                        | 需要修改的UEFI/BIOS（禁用Secure Boot）                           |
| MSI GF72 8RE-032              | Intel Core i7-8750H   | GTX 1060 Mobile (6GB)</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下大概能工作                   | Intel UHD Graphics 630</br>Windows下大概能工作；Linux下大概能工作                                  |                                                                        |                                                                  |
| HP Pavilion G6-2348SG         | Intel Core i7 3632QM  | AMD Radeon HD 7670M</br>Windows下不可能；Linux下不可能                                                 | Intel HD Graphics 4000</br>Windows下不支持4代及更早的Intel CPU；Linux下不支持4代及更早的Intel CPU  |                                                                        |                                                                  |
| ASUS TUF Gaming FX505DY       | AMD Ryzen 5 3550H     | AMD Radeon RX 560X (4GB)</br>Windows下工作，但AMD驱动会遇到43错误；Linux下能工作                       | AMD Radeon Vega 8</br>Windows下大概能工作；Linux下大概能工作                                       |                                                                        |                                                                  |
| ASUS ROG G751JY               | Intel Core i7-4710HQ  | GTX 980M (4GB)</br>Windows下不可能；Linux下不可能                                                      | Intel HD Graphics 4600</br>Windows下不支持4代及更早的Intel CPU；Linux下不支持4代及更早的Intel CPU  |                                                                        | iGPU被禁用，且没有UEFI选项开启                                   |
| ASUS G752VS-BA329T            | Intel Core i7-7700HQ  | GTX 1070 Mobile (8GB)</br>Windows下不可能；Linux下不可能                                               | Intel UHD Graphics 630</br>Windows下不可能；Linux下不可能                                          |                                                                        | iGPU被禁用，且没有UEFI选项开启                                   |
| ASUS ROG G551JW               | Intel Core i7-4720HQ  | GTX 960M (2GB/4GB DDR3)</br>Windows下工作；Linux下未知                                                 | Intel HD Graphics 4600</br>Windows下不支持4代及更早的Intel CPU；Linux下不支持4代及更早的Intel CPU  |                                                                        |                                                                  |
| ASUS G751JM                   | Intel Core i7-4710HQ  | GTX 860M (2GB)</br>Windows下工作；Linux下未知                                                          | Intel HD Graphics 4600</br>Windows下不支持4代及更早的Intel CPU；Linux下不支持4代及更早的Intel CPU  |                                                                        |                                                                  |
| ASUS X550VX                   | Intel Core i5-6300HQ  | GTX 950M (2GB)</br>Windows下工作；Linux下未知                                                          | Intel HD Graphics 530</br>Windows下未知；Linux下未知                                               |                                                                        |                                                                  |
| MSI GS63VR 7RF REV:1.0        | Intel Core i7-7700HQ  | GTX 1060 Mobile (6GB)</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下能工作                       | Intel HD Graphics 630</br>Windows下大概能工作；Linux下大概能工作                                   |                                                                        |                                                                  |
| MSI GS60-040XFR               | Intel Core i7-4720HQ  | GTX 970M (3GB)</br>Windows下工作；Linux下未知                                                          | Intel HD Graphics 4600</br>Windows下不支持4代及更早的Intel CPU；Linux下不支持4代及更早的Intel CPU  |                                                                        |                                                                  |
| MSI GS60 2PC                  | Intel Core i7-4720HQ  | GTX 860M (2GB)</br>Windows下工作；Linux下未知                                                          | Intel HD Graphics 4600</br>Windows下不支持4代及更早的Intel CPU；Linux下不支持4代及更早的Intel CPU  |                                                                        |                                                                  |
| MSI GT70 2PE Dominator Pro    | Intel Core i7-4800MQ  | GTX 880M (GDDR5 8GB/4GB)</br>Windows下工作；Linux下大概能工作                                          | Intel HD Graphics 4600 </br>Windows下不支持4代及更早的Intel CPU；Linux下不支持4代及更早的Intel CPU |                                                                        | dGPU直通需要SeaBIOS而不是UEFI（OVMF）                            |
| Gigabyte Aero 14              | Intel Core™ i7-7700HQ | GTX 1050 Ti (4GB)</br>Windows下工作；Linux下未知                                                       | Intel HD Graphics 630</br>Windows下工作；Linux下未知                                               |                                                                        |                                                                  |
| Gigabyte Aero 15X v8          | Intel Core i7-8750H   | GTX 1070 with Max-Q design (8GB)</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下能工作            | Intel UHD Graphics 630</br>Windows下大概能工作；Linux下大概能工作                                  |                                                                        |                                                                  |
| Lenovo ThinkPad P51           | Intel Core i7-7700HQ  | NVIDIA Quadro M1200 (4GB)</br>Windows下未知；Linux下能工作                                             | Intel UHD Graphics 630</br>Windows下未知；Linux下能工作                                            |                                                                        | 可使用Intel GVT-g以使两张卡同时通过，Bumblebee可在访客模式下使用 |
| Lenovo Legion Y7000           | Intel Core i7-8750H   | GTX 1060 Mobile (6GB)</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下大概能工作                   | Intel UHD Graphics 630</br>Windows下大概能工作；Linux下大概能工作                                  |                                                                        |                                                                  |
| Dell XPS 15 9550              | Intel Core i7-6700HQ  | GTX 960M (2GB)</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下大概能工作                          | Intel HD Graphics 530</br>Windows下大概能工作；Linux下大概能工作                                   |                                                                        |                                                                  |
| Dell XPS 15 9570              | Intel Core i7-8750H   | GTX 1050Ti (4GB)</br>Windows下工作；Linux下大概能工作                                                  | Intel UHD Graphics 630</br>Windows下工作；Linux下大概能工作                                        |                                                                        |                                                                  |
| Dell Precision 7510           | Intel Xeon E3-1200 v5 | Nvidia Quadro M2000M</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下大概能工作                    | Intel HD Graphics P530</br>Windows下大概能工作；Linux下大概能工作                                  |                                                                        |                                                                  |
| OVERPOWERED Gaming Laptop 15+ | Intel Core i7-8750H   | GTX 1060 (6GB)</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下大概能工作                          | Intel UHD Graphics 630</br>Windows下大概能工作；Linux下大概能工作                                  |                                                                        |                                                                  |
| CLEVO P950ER                  | Intel Core i7-8750H   | GTX 1070 with Max-Q design (8GB)</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下大概能工作        | Intel UHD Graphics 630</br>Windows下大概能工作；Linux下大概能工作                                  |                                                                        |                                                                  |
| XMG P505 (Clevo P650SG)       | Intel Core i7-4720HQ  | GTX 970M (4GB)</br>Windows下工作，但某些应用只能在RDP下运行；Linux下大概能工作                         | Intel HD Graphics 4600</br>Windows下不支持4代及更早的Intel CPU；Linux下不支持4代及更早的Intel CPU  |                                                                        | 需要Nvidia驱动(353.82)以在Windows 10下运行                       |
| CLEVO N957TP6                 | Unknown (Intel)       | Unknown (Nvidia)</br>Windows下工作，但Nvidia驱动会遇到43错误；Linux下大概能工作                        | Unknown</br>Windows下大概能工作；Linux下大概能工作                                                 |                                                                        |                                                                  |

可使用以下脚本进行判断。

```
https://github.com/T-vK/MobilePassThrough
```

若没有该芯片，由于Mac不支持双显卡切换技术，为使显卡正常，需要屏蔽独显。大多数笔记本上的双显卡切换是让集显承担图像输出任务，所以不能屏蔽集显，屏蔽会导致黑屏。

可以通过外接显示器判断独显是否独立。外接显示器后在桌面右键，打开NVIDIA控制面板，然后看是否可以调节数字振动这类设置。如果可以，说明此独显可以被独立驱动。

对于本机而言，由于BIOS中有External Gfx Card Primary Display Configuration，理论上可以屏蔽核显以驱动独显。考虑到BIOS中的设置会影响其他系统，此处采用屏蔽Nvidia独显而驱动Intel核显的方案。

对于旧版Mac的独显，可尝试通过purge-wrangler驱动，链接如下。

```
https://github.com/mayankk2308/purge-wrangler
```

#### 查找设备路径

设备路径描述了设备在所有硬件中的具体位置，为类似`_SB.PCI0.PEG0.PEGP`的形式。

##### 通过gfxutil

下载`gfxutil`后打开终端，并切换到gfxutil所在路径，执行以下命令以输出显卡设备路径。

```
// 独显
gfxutil -f GFX0

// 核显
gfxutil -f IGPU
```

##### 通过Windows

打开Windows下的设备管理器，在独显设备上右键单击`属性`，在详细信息标签卡下拉菜单选择`BIOS设备名称`即可。

##### 通过ACPI表

在Clover引导界面按下`F4`，进入系统后打开EFI/CLOVER/ACPI/origin，可得到本机所有ACPI文件。复制到任一位置后打开终端，切换到复制到的位置并执行以下命令。

```
grep -l _OFF *.aml
grep -l _INI *.aml
```

检查输出并记录两个输出中均存在的文件。打开这些文件并查找\_OFF方法，如果这个方法在PowerShell宏中（即由PowerShell大括号括住），则舍弃。找到独立的\_OFF方法并记录其设备路径即可。

#### 驱动Nvidia显卡

Nvidia显卡一般免驱，部分显卡打开Inject Nvidia即可驱动成功。对于未受支持的显卡，则需要安装Nvidia WebDriver。此驱动最新版只适用于10.13，因此需要进行修补。

可使用Benjamin-Dobell的脚本，仓库如下。

```
https://github.com/Benjamin-Dobell/nvidia-update
```

在终端输入以下命令以启动安装脚本。

```
curl -O https://raw.githubusercontent.com/Benjamin-Dobell/nvidia-update/master/nvidia-update.sh
chmod 755 nvidia-update.sh
./nvidia-update.sh -f
```

安装完成后重启，在系统设置中已经能够看到Nvidia控制面板。若未驱动，则需要在Clover的System Parameters下勾选NvidiaWeb。

若为笔记本，独显通常不可驱动。若为台式机，在Catalina上独显无法开启硬件加速。若该显卡正常驱动，可安装WebDriver和CUDA Driver获得更好的体验，下载链接如下。

```
# WebDriver
https://gfe.nvidia.com/mac-update
https://www.nvidia.com/download/driverResults.aspx/149652/
https://www.nvidia.com/download/driverResults.aspx/125379/en-us
https://www.insanelymac.com/forum/topic/324195-nvidia-web-driver-updates-for-macos-high-sierra-update-nov-13-2020/

# WebDriver Manager
https://hackintosher.com/forums/attachments/webdrivermanager-2-9-4-zip.1289/

# CUDA Driver
https://www.nvidia.com/en-us/drivers/cuda/mac-driver-archive/
```

<details>
<summary>【进阶】旧版Nvidia GPU用于Mojave/Catalina</summary>

部分旧版GPU最多仅支持到High Sierra，可通过修改系统文件的方式实现驱动。下载链接如下。

```
https://www.insanelymac.com/forum/topic/339035-pre-release-macos-catalina/page/21/?tab=comments#comment-2677545
```

需要替换以下文件。

```
# Frameworks
/System/Library/Frameworks/CoreDisplay.framework
/System/Library/Frameworks/OpenGL.framework
/System/Library/PrivateFrameworks/SkyLight.framework
/System/Library/PrivateFrameworks/GPUSupport.framework

# Patched Catalina Kexts
/System/Library/Extensions/IOHIDFamily.kext
/System/Library/Extensions/IOSurface.kext 

# nVidia Kexts from 10.13.6 for Legacy Tesla Cards
/System/Library/Extensions/GeForceGA.bundle
/System/Library/Extensions/GeForceTesla.kext
/System/Library/Extensions/GeForceTeslaGLDriver.bundle
/System/Library/Extensions/GeForceTeslaVADriver.bundle
/System/Library/Extensions/IOGraphicsFamily.kext
/System/Library/Extensions/IONDRVSupport.kext
/System/Library/Extensions/NVDANV50HalTesla.kext
/System/Library/Extensions/NVDAResmanTesla.kext
```

并删除以下内容。删除后修复权限并重建缓存即可。

```
/System/Library/UserEventPlugins/com.apple.telemetry.plugin
```
</details>

<details>
<summary>【进阶】OC引导</summary>

OpenCore需添加EFI字符串。在配置文件添加以下设备即可。

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>[DEVICEPATH]</key>
    <dict>
        <key>@0,compatible</key>
        <string>NVDA,NVMac</string>
        <key>@0,device_type</key>
        <string>display</string>
        <key>@0,name</key>
        <string>NVDA,Display-A</string>
        <key>@1,compatible</key>
        <string>NVDA,NVMac</string>
        <key>@1,device_type</key>
        <string>display</string>
        <key>@1,name</key>
        <string>NVDA,Display-B</string>
        <key>NVCAP</key>
        <data>
        [OUTPUTS]
        </data>
        <key>NVPM</key>
        <data>
        AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
        </data>
        <key>VRAM,totalsize</key>
        <string>[MEMORYSIZE]</string>
        <key>device_type</key>
        <string>NVDA,GeForce</string>
        <key>model</key>
        <string>[MODELNAME]</string>
        <key>name</key>
        <string>NVDA,Parent</string>
        <key>rom-revision</key>
        <string>0x302e3176</string>
    </dict>
    </dict>
</plist>
```

注意需根据以下内容替换。

|     选项     |                                                                                           内容                                                                                          |
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [DEVICEPATH] | 设备路径                                                                                                                                                                                |
| [MODELNAME]  | 设备名称                                                                                                                                                                                |
| [MEMORYSIZE] | 32 - 0x02000000</br>64 - 0x04000000</br>128 - 0x08000000</br>256 - 0x10000000</br>320 - 0x14000000</br>512 - 0x20000000</br>640 - 0x28000000</br>768 - 0x30000000</br>1024 - 0x40000000 |
| [OUTPUTS]             |  DVI-I / DVI-I - BAAAAAAAAwAMAAAAAAAABwAAAAA=</br>VGA / DVI-I  - BAAAAAAAAQAGAAAAAAAAAAAAAAA=</br>DVI-I / VGA - BAAAAAAAAwAEAAAAAAAABwAAAAA=                                                                                                                                                                                       |
</details>

#### 驱动Intel显卡

Intel显卡位于地址0x00020000，在DSDT中可通过搜索`Name (_ADR, 0x00020000)`定位到显卡。

打开Hackintool，在缓冲帧菜单项选择macOS 10.14，在IntelGen菜单项选择显卡的次代。本机为Intel HD Graphics 620，选择Kaby Lake。然后选择PlatformID，本机选择0×59160000。具体对应架构和PlatformID参见附录。

点击应用补丁选项卡，进行以下设置。

```
# 通用
选择设备属性，勾选自动侦测变化、全部、接口、基本显存、EDID、图形卡、音频、PCI设备

# Advenced
勾选将DP映射到HDMI、使用英特尔HDMI、修复热插拔重启、HDMI无限循环修复、仿冒声卡ID、显存2048MB、启用HDMI20（4K）、缓冲帧接口数限制：3
勾选仿冒图形卡ID，选择对应显卡设备
```

点击Generate Patch生成显卡驱动补丁。点击File-Export-Clover config.plist，路径选择EFI/CLOVER并确认替换。注意，Hackintool会将原来的config.plist和生成的补丁进行合成，替换以后的config.plist为原有基础上添加了显卡补丁的配置文件，原有配置文件则被备份为config-backup.plist。

<details>
<summary>【进阶】DeviceProperties中显卡设备参数含义</summary>

framebuffer-unifiedmem用于设置显存参数，可随意设置，仅在系统设置中显示，无实际作用。注意，UHD630经测试最高只能修改到4080MB，再往上会变成0MB。
</details>

#### 驱动AMD显卡

AMD显卡大部分免驱，部分需要通过伪装ID的方式驱动。

<details>
<summary>【进阶】伪装ID</summary>

部分GPU需要将其欺骗为其它显卡以正常工作。列表如下。

```
R9 290/390
R9 280/380
R7 270/370
R9 260/360
R7 250
R7 240
```

以R9 390为例，最接近的可驱动卡为390X，可得vendor ID为1002，device ID为67B0。仅需将device ID进行处理，结果如下，注意遵循小端规则。

```
"device-id",
Buffer (0x04)
{
     0xB0, 0x67, 0x00, 0x00
},
```

下载以下文件并用MaciASL打开。

```
https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/decompiled/SSDT-GPU-SPOOF.dsl.zip
```

将以下内容修改为显卡的设备路径。

```
External (_SB_.PCI0, DeviceObj)
External (_SB_.PCI0.PEG0.PEGP, DeviceObj)
```

然后将前面修改过的device ID放入该SSDT中。同时修改model，该部分仅为装饰性作用。

```
"model",
Buffer ()
{
    "AMD Radeon R9 390"
}
```

另存为aml文件后放置在Clover的ACPI/patched即可。
</details>

可尝试PyVega以实现超频和电压调整。

```
https://github.com/corpnewt/PyVega
```

#### 禁用显卡

必须在BIOS中关闭CSM，才可使以下方法工作。

##### 通过添加引导标志

保证Whatevergreen存在，在Clover引导标志中添加`-wegnoegpu`。此方法不能保证始终正常工作。

##### 通过添加独显设备并禁用

注意，进入该设备路径的其它设备也将获得这些属性，从而失效，即会禁用同一品牌的所有显卡，也会禁用开普勒GPU。其它PCIe驱动器也可用此法禁用。

查找到独显设备路径，对于Nvidia一般为`\_SB.PCI0.PEG0.PEGP`，对于AMD一般为`\_SB.PCI0.PEGP.DGFX`。找到后在Clover的Device-Add Properties下添加该独显路径，并填写以下内容。

对于Nvidia显卡采用以下内容。

| Device |    Key     |      Value       | Disabled | Value Type |
|--------|------------|------------------|----------|------------|
| NVidia | name       | 23646973706C6179 | False    | DATA       |
| NVidia | IOName     | \#display        | False    | STRING     |
| NVidia | class-code | FFFFFFFF         | False    | DATA       |

对于AMD显卡则采用以下内容。

| Device |    Key     |      Value       | Disabled | Value Type |
|--------|------------|------------------|----------|------------|
| ATI    | name       | 23646973706C6179 | False    | DATA       |
| ATI    | IOName     | \#display        | False    | STRING     |
| ATI    | class-code | FFFFFFFF         | False    | DATA       |
| ATI    | vendor-id  | FFFF0000         | False    | DATA       |
| ATI    | device-id  | FFFF0000         | False    | DATA       |

##### 通过SSDT

查找到独显设备路径后，打开MaciASL并新建文件，复制以下代码并将`_SB.PCI0.PEG0.PEGP`修改为所找到的设备路径，保存为aml文件并放到EFI/CLOVER/ACPI/hotpatch，然后添加change _DSM to XDSM更名补丁。

对于Nvidia显卡采用以下SSDT。

```
DefinitionBlock ("", "SSDT", 2, "hack", "spoof", 0)
{
    Method(_SB.PCI0.PEG0.PEGP._DSM, 4)
    {
        If (!Arg2) { Return (Buffer() { 0x03 } ) }
        Return (Package()
        {
            "name", Buffer() { "#display" },
            "IOName", "#display",
            "class-code", Buffer() { 0xFF, 0xFF, 0xFF, 0xFF },
        })
    }
}
```

对于AMD显卡采用以下SSDT。

```
DefinitionBlock ("", "SSDT", 2, "hack", "spoof", 0)
{
    Method(_SB.PCI0.PEG0.PEGP._DSM, 4)
    {
        If (!Arg2) { Return (Buffer() { 0x03 } ) }
        Return (Package()
        {
            "name", Buffer() { "#display" },
            "IOName", "#display",
            "class-code", Buffer() { 0xFF, 0xFF, 0xFF, 0xFF },
            "vendor-id", Buffer() { 0xFF, 0xFF, 0,  0 },
            "device-id", Buffer() { 0xFF, 0xFF, 0, 0 },
        })
    }
}
```

通用版SSDT如下。

```
DefinitionBlock ("", "SSDT", 2, "DRTNIA", "spoof", 0x00000000)
{
    External (_SB_.PCI0.PEG0.PEGP, DeviceObj)

    Method (_SB.PCI0.PEG0.PEGP._DSM, 4, NotSerialized)
    {
        If ((!Arg2 || !_OSI ("Darwin")))
        {
            Return (Buffer (One)
            {
                 0x03
            })
        }

        Return (Package (0x0A)
        {
            "name", 
            Buffer (0x09)
            {
                "#display"
            }, 

            "IOName", 
            "#display", 
            "class-code", 
            Buffer (0x04)
            {
                 0xFF, 0xFF, 0xFF, 0xFF
            }
        })
    }
}
```

仓库如下。

```
https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/decompiled/SSDT-GPU-DISABLE.dsl.zip
```

#### 屏蔽独显

查找到独显设备路径后，打开MaciASL并新建文件，复制以下代码并将`_SB.PCI0.PEG0.PEGP`修改为所找到的设备路径，保存为aml文件并放到EFI/CLOVER/ACPI/hotpatch。

<details>
<summary>【进阶】禁用原理</summary>

该SSDT通过调用显卡设备中的`_OFF`方法实现屏蔽独显。
</details>

```
https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/decompiled/SSDT-dGPU-Off.dsl.zip
```

对于部分显卡，该方法无法使其正常关闭，则可通过发送D3 state的方式使显卡处于最低耗能状态。使用以下SSDT即可，操作同上。

```
https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/decompiled/SSDT-NoHybGfx.dsl.zip
```

#### 屏幕亮度

##### 启用调节

对于笔记本，可使用BrightnessKeys.kext，链接如下，

```
https://github.com/acidanthera/BrightnessKeys
```

对于台式机，打开Maciasl，新建文件并复制以下内容，保存为SSDT-PNLF.aml并放入Clover的ACPI/patched下。

对于Coffee Lake及更新CPU，使用以下补丁。

```
https://github.com/acidanthera/OpenCorePkg/blob/master/Docs/AcpiSamples/Source/SSDT-PNLFCFL.dsl
```

其它使用以下补丁。

```
https://github.com/acidanthera/OpenCorePkg/blob/master/Docs/AcpiSamples/Source/SSDT-PNLF.dsl
```

或以下内容。

```
DefinitionBlock ("", "SSDT", 2, "hack", "_PNLF", 0x00000000)
{
    External (_SB_.PCI0.IGPU, DeviceObj)
    External (RMCF.BKLT, IntObj)
    External (RMCF.FBTP, IntObj)
    External (RMCF.GRAN, IntObj)
    External (RMCF.LEVW, IntObj)
    External (RMCF.LMAX, IntObj)

    Scope (_SB.PCI0.IGPU)
    {
        OperationRegion (RMP3, PCI_Config, Zero, 0x14)
    }

    Device (_SB.PCI0.IGPU.PNLF)
    {
        Name (_ADR, Zero)
        Name (_HID, EisaId ("APP0002"))
        Name (_CID, "backlight")
        Name (_UID, Zero)
        Name (_STA, 0x0B)
        Field (^RMP3, AnyAcc, NoLock, Preserve)
        {
            Offset (0x02), 
            GDID,   16, 
            Offset (0x10), 
            BAR1,   32
        }

        OperationRegion (RMB1, SystemMemory, (BAR1 & 0xFFFFFFFFFFFFFFF0), 0x000E1184)
        Field (RMB1, AnyAcc, Lock, Preserve)
        {
            Offset (0x48250), 
            LEV2,   32, 
            LEVL,   32, 
            Offset (0x70040), 
            P0BL,   32, 
            Offset (0xC2000), 
            GRAN,   32, 
            Offset (0xC8250), 
            LEVW,   32, 
            LEVX,   32, 
            Offset (0xE1180), 
            PCHL,   32
        }

        Method (_INI, 0, NotSerialized)
        {
            Local4 = One
            If (CondRefOf (\RMCF.BKLT))
            {
                Local4 = \RMCF.BKLT
            }

            If ((Zero == (One & Local4)))
            {
                Return (Zero)
            }

            Local0 = ^GDID
            Local2 = Ones
            If (CondRefOf (\RMCF.LMAX))
            {
                Local2 = \RMCF.LMAX
            }

            Local3 = Zero
            If (CondRefOf (\RMCF.FBTP))
            {
                Local3 = \RMCF.FBTP
            }

            If ((Zero == Local3))
            {
                If ((Ones != Match (Package (0x10)
                                {
                                    0x010B, 
                                    0x0102, 
                                    0x0106, 
                                    0x1106, 
                                    0x1601, 
                                    0x0116, 
                                    0x0126, 
                                    0x0112, 
                                    0x0122, 
                                    0x0152, 
                                    0x0156, 
                                    0x0162, 
                                    0x0166, 
                                    0x016A, 
                                    0x46, 
                                    0x42
                                }, MEQ, Local0, MTR, Zero, Zero)))
                {
                    Local3 = One
                }
                Else
                {
                    Local3 = 0x02
                }
            }

            If ((One == Local3))
            {
                If ((Ones == Local2))
                {
                    Local2 = 0x0710
                }

                Local1 = (^LEVX >> 0x10)
                If (!Local1)
                {
                    Local1 = Local2
                }

                If ((Local2 != Local1))
                {
                    Local0 = ((^LEVL * Local2) / Local1)
                    Local3 = (Local2 << 0x10)
                    If ((Local2 > Local1))
                    {
                        ^LEVX = Local3
                        ^LEVL = Local0
                    }
                    Else
                    {
                        ^LEVL = Local0
                        ^LEVX = Local3
                    }
                }
            }
            ElseIf ((0x02 == Local3))
            {
                If ((Ones == Local2))
                {
                    If ((Ones != Match (Package (0x16)
                                    {
                                        0x0D26, 
                                        0x0A26, 
                                        0x0D22, 
                                        0x0412, 
                                        0x0416, 
                                        0x0A16, 
                                        0x0A1E, 
                                        0x0A1E, 
                                        0x0A2E, 
                                        0x041E, 
                                        0x041A, 
                                        0x0BD1, 
                                        0x0BD2, 
                                        0x0BD3, 
                                        0x1606, 
                                        0x160E, 
                                        0x1616, 
                                        0x161E, 
                                        0x1626, 
                                        0x1622, 
                                        0x1612, 
                                        0x162B
                                    }, MEQ, Local0, MTR, Zero, Zero)))
                    {
                        Local2 = 0x0AD9
                    }
                    ElseIf ((Ones != Match (Package (0x04)
                                    {
                                        0x3E9B, 
                                        0x3EA5, 
                                        0x3E92, 
                                        0x3E91
                                    }, MEQ, Local0, MTR, Zero, Zero)))
                    {
                        Local2 = 0xFFFF
                    }
                    Else
                    {
                        Local2 = 0x056C
                    }
                }

                If ((Zero == (0x02 & Local4)))
                {
                    Local5 = 0xC0000000
                    If (CondRefOf (\RMCF.LEVW))
                    {
                        If ((Ones != \RMCF.LEVW))
                        {
                            Local5 = \RMCF.LEVW
                        }
                    }

                    ^LEVW = Local5
                }

                If ((0x04 & Local4))
                {
                    If (CondRefOf (\RMCF.GRAN))
                    {
                        ^GRAN = \RMCF.GRAN
                    }
                    Else
                    {
                        ^GRAN = Zero
                    }
                }

                Local1 = (^LEVX >> 0x10)
                If (!Local1)
                {
                    Local1 = Local2
                }

                If ((Local2 != Local1))
                {
                    Local0 = ((((^LEVX & 0xFFFF) * Local2) / Local1) | 
                        (Local2 << 0x10))
                    ^LEVX = Local0
                }
            }

            If ((Local2 == 0x0710))
            {
                _UID = 0x0E
            }
            ElseIf ((Local2 == 0x0AD9))
            {
                _UID = 0x0F
            }
            ElseIf ((Local2 == 0x056C))
            {
                _UID = 0x10
            }
            ElseIf ((Local2 == 0x07A1))
            {
                _UID = 0x11
            }
            ElseIf ((Local2 == 0x1499))
            {
                _UID = 0x12
            }
            ElseIf ((Local2 == 0xFFFF))
            {
                _UID = 0x13
            }
            Else
            {
                _UID = 0x63
            }
        }
    }
}
```

重启电脑后进入系统偏好设置-显示器，若出现亮度调节滑块则已成功。

完成后可通过NativeDisplayBrightness，实现通过F1/F2控制显示器亮度。

```
https://github.com/Bensge/NativeDisplayBrightness
```

也可尝试IntelBacklight，或ACPIBacklight。

```
https://github.com/RehabMan/OS-X-Intel-Backlight
https://github.com/RehabMan/OS-X-ACPI-Backlight
```

<details>
<summary>【进阶】DSDT PNLF补丁</summary>

对于SandyBridge和IvyBridge如下。

```
into_all device label PNLF remove_entry;
into scope label _SB insert
begin
Device (PNLF)\n
        {\n
            Name (_HID, EisaId ("APP0002"))  // _HID: Hardware ID\n
            Name (_CID, "backlight")  // _CID: Compatible ID\n
            Name (_UID, 0x0E)  // _UID: Unique ID\n
            Name (_STA, 0x0B)  // _STA: Status\n
        }\n
end
```

对于Haswell和Broadwell如下。

```
into_all device label PNLF remove_entry;
into scope label _SB insert
begin
Device (PNLF)\n
        {\n
            Name (_HID, EisaId ("APP0002"))  // _HID: Hardware ID\n
            Name (_CID, "backlight")  // _CID: Compatible ID\n
            Name (_UID, 0x0F)  // _UID: Unique ID\n
            Name (_STA, 0x0B)  // _STA: Status\n
        }\n
end
```

对于SkyLake和Kabylake如下。

```
into_all device label PNLF remove_entry;
into scope label _SB insert
begin
Device (PNLF)\n
        {\n
            Name (_HID, EisaId ("APP0002"))  // _HID: Hardware ID\n
            Name (_CID, "backlight")  // _CID: Compatible ID\n
            Name (_UID, 0x10)  // _UID: Unique ID\n
            Name (_STA, 0x0B)  // _STA: Status\n
        }\n
end
```

对于Coffeelake、WhiskeyLake、CometLake和Ice Lake如下。

```
into_all device label PNLF remove_entry;
into scope label _SB insert
begin
Device (PNLF)\n
        {\n
            Name (_HID, EisaId ("APP0002"))  // _HID: Hardware ID\n
            Name (_CID, "backlight")  // _CID: Compatible ID\n
            Name (_UID, 0x13)  // _UID: Unique ID\n
            Name (_STA, 0x0B)  // _STA: Status\n
        }\n
end
```
</details>

<details>
<summary>【进阶】DSDT的相关代码</summary>

LMAX变量代表PWM背光最大值，示例如下。若设置为0则在引导时使用BIOS寄存器值。

```
Name(LMAX, 0x56c)
```
</details>

##### 亮度恢复

AppleBacklight.kext将当前亮度级别存储在NVRAM中，以便在重新启动后进行恢复。

为了使恢复正常工作，必须正确实施NVRAM。且Clover的配置文件中，SystemParameters-BacklightLevel不应设值，ACPI-DSDT-Fixes-AddPNLF应关闭

若电脑有环境光传感器，则可能会对亮度恢复造成干扰。可在DSDT中通过查找`ACPI0008`检查是否存在光传感器。若有，则可通过编辑其_STA方法禁用，示例如下。

```
Device (ALSD)
{
    Name (_HID, "ACPI0008")  // _HID: Hardware ID
    Method (_STA, 0, NotSerialized)  // _STA: Status
    {
        Return (0)
    }
...
}
```

#### 效果检验

重启后显卡正常情况下已经驱动，Dock栏变为半透明。

点击左上角苹果按钮，选择关于本机，若图形卡一栏显示2048MB而不是7MB，则核显驱动成功。在系统报告-图形卡中若不能看到所屏蔽的独显，则独显屏蔽成功。点击核显，若有`Metal:    支持，功能集macOS GPUFamily2 v1`字样，则metal支持打开成功。

显卡驱动后需检验显卡硬件加速（QE/CI）是否已经打开。如果能够运行象棋游戏、屏幕保护程序正常工作、Grapher能看到三维图像、截屏功能正常，则硬件加速已打开。

也可使用VDADecoderChecker或VideoProc检测。对于VideoProc，打开应用后进入`设置`，点击`硬件加速引擎`旁边的`选项`，查看检测结果即可。VideoProc下载链接如下。

```
https://www.videoproc.com/
```

对于VDADecoderChecker，下载链接如下。双击即可进行检查。若不正常，需保证iGPU注入正确，若无效则尝试更改SMBIOS。

```
https://github.com/cylonbrain/VDADecoderCheck
https://i.applelife.ru/2019/05/451893_10.12_VDADecoderChecker.zip
```

<details>
<summary>【进阶】对于Catalina及更高版本</summary>

由于默认情况下不显示来自AppleGVA的调试信息，因此需要在系统日志查看结果。在终端输入以下命令。

```
defaults write com.apple.AppleGVA enableSyslog -boolean true
log stream --style compact --predicate 'eventMessage CONTAINS "GVA"'
```

输入后开启VDADecoderChecker。完成后输入以下命令禁用AppleGVA调试。

```
defaults delete com.apple.AppleGVA enableSyslog
```
</details>

<details>
<summary>【进阶】Big Sur中的错误</summary>

若出现VDADecoderCreate failed. err: -12473错误，在有AMD独显的情况下，可在终端输入以下命令。

```
defaults write com.apple.AppleGVA gvaForceAMDAVCDecode -boolean yes
```
</details>

#### DRM支持

若未开启DRM，则Apple TV+、Amazon Prime、Netflix将无法正常观看。开启DRM需要支持的dGPU。

<details>
<summary>【进阶】其它系统支持性</summary>

对于Big Sur和Safari 14，系统不再提供软件DRM支持与传统硬件DRM支持，WhatEverGreen目前未提供DRM支持。在Catalina中，对于Intel，Haswell及更新的核显不提供DRM支持。

iGPU的DRM中断通过WhatEverGreen修复，在10.12.2及更低系统起作用。
</details>

DRM类型如下。

|       类型       |                                   说明                                  |
|------------------|-------------------------------------------------------------------------|
| FairPlay 1.x     | 基于软件的DRM，用于支持旧版Mac                                          |
| FairPlay 2.x/3.x | 基于硬件的DRM，用于Netflix和Amazon Prime，需Polaris+的AMD GPU以保证工作 |
| FairPlay 4.x     | 混合DRM，用于AppleTV+，需无iGPU (Xeon)或有Polaris+的AMD GPU以保证工作   |

首先通过VDADecoderChecker保证硬件正常工作。然后通过以下视频检查各DRM类型。

```
# FairPlay 1.x
https://drive.google.com/file/d/12pQ5FFpdHdGOVV6jvbqEq2wmkpMKxsOF/view

# FairPlay 2.x/3.x
# 播放预告片
https://www.amazon.com/Spider-Man-Far-Home-Tom-Holland/dp/B07TP6D1DP

# FairPlay 4.x
打开Apple TV+并观看任意预告片
```

根据以下列表设置SMBIOS，并添加启动参数或添加设备属性即可。以`shikigva=80`为例，设备属性如下。注意应当仅对一个显卡注入shikigva属性，否则WhatEverGreen将使用它首先找到的任何内容，并且不能保证一致。

| Properties Key | Properties Value | Value Type |
|----------------|------------------|------------|
| shikigva       |               80 | Number     |

注意，IQSV代表英特尔快速同步视频。这仅在iGPU存在并启用且设置正确时才有效。

```
https://github.com/acidanthera/WhateverGreen/blob/master/Manual/FAQ.Chart.md
```

#### 显示修复

若出现屏幕花屏，可以尝试将DVI换为HDMI，或注入EDID。

##### 平滑字体

在终端输入以下命令即可。

```
# 开启
defaults write -g CGFontRenderingFontSmoothingDisabled -bool NO

# 设置字体样式
# 3为最粗，1为最细
defaults -currentHost write -globalDomain AppleFontSmoothing -int 3
// defaults -currentHost write -globalDomain AppleFontSmoothing -int 2
// defaults -currentHost write -globalDomain AppleFontSmoothing -int 1

# 关闭
defaults write -g CGFontRenderingFontSmoothingDisabled -bool YES
```

##### Hidpi

HiDPI即High Dots Per Inch，用四个硬件像素渲染一个图像像素。开启Hidpi可使显示更清晰。

###### 通过脚本

在终端下输入以下命令打开一键HiDPI脚本，安装以获得原生屏幕缩放体验。

```
sh -c "$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi.sh)"

# 或以下命令
bash -c "$(curl -fsSL https://gitee.com/kirainmoe/static-files/raw/master/hidpi.sh)"
```

###### 通过RDM

打开DarwinDumper，只勾选EDID，点击左侧的Run，会在桌面生成EDID文件夹。下载链接如下。

```
https://mac.softpedia.com/get/Utilities/DarwinDumper.shtml
```

下载FixEDID，链接如下。

```
https://github.com/andyvand/FixEDID
```

打开并点击Open EDID binary file，选择桌面文件夹的EDID/EDID.bin。选择对应显示比例的显示器，此处为Apple MacBook Pro Display（16:10）。

在右侧输入想设置的分辨率，点击Add Resolutions添加分辨率，点击Make在桌面生成文件。参考分辨率如下。

```
3840×2160
3200×1800
2880×1620
2560×1600
2560×1440
1920×1080
1820×1200
1680×1050
1600×900
1440×810
1440×900
1440×810
1344×1008
1344×756
1280×960
1280×800
1280×720
1024×768
1024×576
960×600
960×540
840×525
840×524
800×600
800×450
720×450
640×480
```

将桌面的DisplayVendorID-xxx放到/System/Library/Displays/Contents/Resources/Overrides。安装`RDM`并重启电脑，即可在RDM看到需要的分辨率，链接如下。

```
http://avi.alkalay.net/software/RDM/RDM-2.2.dmg
```

###### 通过手动设置

<details>
<summary>【进阶】对于Big Sur</summary>

该方法适用于Big Sur，将最后生成的文件放置于/Library/Displays/Contents/Resources/Overrides即可。

具体可在终端使用以下命令。

```
sudo mkdir -p /Library/Displays/Contents/Resources/Overrides/

# DisplayProductID-413c和DisplayVendorID-10ac根据显示器自行修改
sudo cp ~/Downloads/DisplayProductID-413c.plist /Library/Displays/Contents/Resources/Overrides/DisplayVendorID-10ac/DisplayProductID-413
```
</details>

打开终端并输入以下命令。

```
sudo defaults write /Library/Preferences/com.apple.windowserver.plist DisplayResolutionEnabled -bool true
ioreg -lw0 | grep IODisplayPrefsKey
```

输出类似如下信息，其中所有外部监视器由AppleDisplay标识，内部监视器由AppleBacklightDisplay标识。在行末可识别出DisplayVendorID和DisplayProductID，此处为`10ac`和`d06e`。

```
"IODisplayPrefsKey" = "IOService:/AppleACPIPlatformExpert/PCI0@0/AppleACPIPCI/IGPU@2/AppleIntelFramebuffer@2/display0/AppleDisplay-10ac-d06e"
```

打开以下网页并输入刚才得到的DisplayVendorID和DisplayProductID，DisplayProductName可以随意。注意一个分辨率需填写两个Scale Resolutions，其中第一个是原分辨率，另一个是长宽均为两倍后的分辨率，如添加1920×1080，则需填入3840×2160和1920×1080。注意相近的分辨率将会被系统过滤。

```
https://codeclou.github.io/Display-Override-PropertyList-File-Parser-and-Generator-with-HiDPI-Support-For-Scaled-Resolutions/
```

调整完成后下载plist文件，去掉扩展名并放在DisplayVendorID-10ac文件夹，其中10ac更改为自己的VendorID。将文件夹复制到/System/Library/Displays/Contents/Resources/Overrides并重启即可。

##### 注入EDID

注入EDID可修复笔记本显示器内屏黑屏或花屏的问题。若前面选择采用Hidpi一键脚本，则无需进行此步。

###### 通过patch-edid.rb

打开终端并输入以下命令以下载脚本。

```
curl -O https://gist.github.com/ejdyksen/8302862/raw/patch-edid.rb
```

打开脚本文件并查找`AppleDisplay`，其代表外接显示器，若为内接显示器则需修改为`AppleBacklightDisplay`。然后继续在终端输入以下命令以运行并生成配置文件。

```
sudo ruby patch-edid.rb
```

将生成的配置文件复制到/System/Library/Displays/Contents/Resources/Overrides/DisplayVendorID-xxx（对于El Capitan及以前版本为/System/Library/Displays/Overrides/DisplayVendorID-xxx），若已存在配置文件，则将两个文件的内容合并，重启即可。

###### 通过Clover

在终端分别输入以下命令并记录其输出。其中第一个输出为EDID信息，另外两个分别为屏幕设备的VendorID和ProductID。

```
ioreg -lw0 | grep -i "IODisplayEDID" | sed -e 's/.*<//' -e 's/>//'
ioreg -l | grep "DisplayVendorID"
ioreg -l | grep "DisplayProductID"
```

打开Clover的config.plist，切换到Graphics，将三者分别粘贴到对应的位置，注意VendorID和ProductID需要转换为十六进制。勾选`Inject EDID`，保存并重启即可。

###### 通过Hackintool

打开Hackintool，进入显示器，选择要编辑的显示器，可添加或修复监视器范围，以及修改分辨率。

点击导出，将DisplayVendorID-x和Icons.plist复制到/System/Library/Displays/Contents/Resources/Overrides（对于El Capitan及以前版本为/System/Library/Displays/Overrides）即可。

也可将DisplayEDID-x-x.kext复制到Clover的kexts文件夹。

#### 常见问题

##### 部分iGPU唤醒中断

Apple对AppleGraphicsPowerManagement.kext中进行的修改导致。需要添加启动参数igfxonln=1以强制所有显示器联机。

##### NVMe内核崩溃

部分配备iGPU的系统（Sandy Lake/Coffee Lake等）可能会导致系统在低功耗状态下不稳定。需要添加启动参数forceRenderStandby=0以禁用RC6渲染待机。

##### Ice Lake笔记本出现panic，为Cannot allow DC9 without disallowing DC6

状态转换问题，需要添加启动参数-noDC9或-nodisplaysleepDC6。

##### 带有AMD dGPU的4k显示器无法随机唤醒

AGDC设置引起。在配置文件中定位到该设备的设备属性，添加以下项即可。

|       选项       | 类型 | 内容 |
|------------------|------|------|
| CFG,CFG_USE_AGDC | Data |   00 |

### 有线网卡

几乎所有的有线网卡都受支持。

#### Realtek

Realtek L8200A不受支持。

以Realtek RTL8111有线网卡为例，网络上寻找对应驱动的kext，并放入Clover的kexts/Others即可驱动。

驱动后进入系统偏好设置-网络，可看到有线网卡。或点击左上角苹果按钮，选择关于本机-系统报告…，在`以太网卡`中可以看到有线网卡。

```
# Realtek RTL810X（RTL8101E/8102E/8103E/8401E/8105E/8402/8106E/8106EUS）
http://www.insanelymac.com/forum/topic/296190-driver-for-realteks-rtl810x-fast-ethernet-series

# Realtek RTL8111X/8168X（X=无/B/C/D/E/F/G）[Gigabit Ethernet]
http://www.insanelymac.com/forum/topic/287161-new-driver-for-realtek-rtl8111
https://github.com/Mieze/RTL8111_driver_for_OS_X
https://code.google.com/p/os-x-realtek-network/downloads/list
https://github.com/SergeySlice/RealtekLANv3
http://lnx2mac.blogspot.com/p/realtekrtl81xx-osx-driver.html

# Realtek RTL8125 [2.5Gb Ethernet]
https://github.com/Mieze/LucyRTL8125Ethernet

# Realtek RTL8100
https://github.com/Mieze/RealtekRTL8100
```

#### Intel

Intel有线网卡驱动下载链接如下。不支持Intel I225 2.5Gb NIC、Intel I225 2.5Gb NIC、Intel 10Gb server NICs、Mellanox and Qlogic server NICs。

```
# 新版，支持82578LM/82578LC/82578DM/82578DC/82579LM/82579V/I217LM/I217V/I218LM/I218V/I218LM2/I218V2/I218LM3/I219V/I219LM/I219V2/I219LM2/I219LM2
https://github.com/Mieze/IntelMausiEthernet
https://github.com/acidanthera/IntelMausi

# 旧版
https://github.com/chris1111/AppleIntelE1000e

# 支持82575/82576/82580/dh89xxcc/i350/i210/i211
https://www.tonymacx86.com/resources/appleigb.323/

# 支持I211/I350
https://github.com/khronokernel/SmallTree-I211-AT-patch

# 支持I211
https://github.com/suxiaogang/asrock-deskmini-110-hackintosh/tree/master/EFI/CLOVER/kexts/Other/Backup/SmallTree-Intel-211-AT-PCIe-GBE.kext
https://cdn.discordapp.com/attachments/390417931659378688/556912824228773888/SmallTree-Intel-211-AT-PCIe-GBE.kext.zip

# 支持82546EB/82545EM/82546EB/82545GM/82571EB
https://small-tree.com/smalltreeintel8254x-3-9-0-dmg/

# 支持82598EB/82599EB/82599ES
https://small-tree.com/smalltreeintel8259x-3-5-0-dmg/
```

Intel i225-V需要欺骗为被支持的i225LM，具体为在Clover的设备属性下添加路径`PciRoot(0x0)/Pci(0x1C,0x1)/Pci(0x0,0x0)`，其中具有键device-id，类型为Data，值为F2150000。完成欺骗后通过AppleIntelI210Ethernet驱动即可。若出现panic，则设备路径应改为类似`PciRoot(0x0)/Pci(0x1C,0x4)/Pci(0x0,0x0)`。

#### Broadcom

对于BCM5722 NetXtreme/NetLink，可用BCM5722D，链接如下。适用于10.6及更高版本。

```
https://github.com/chris1111/BCM5722D
```

其它则需要FakePCIID+FakePCIID_BCM57XX_as_BCM57765。

#### AMD

I211-AT驱动下载链接如下。

```
https://github.com/khronokernel/SmallTree-I211-AT-patch/releases
```

#### Atheros

Atheros有线网卡驱动下载链接如下。

```
# Qualcomm Atheros E2200
# 支持AR816x/AR817x/Killer E220x/Killer E2400/Killer E2500
https://github.com/Mieze/AtherosE2200Ethernet

# Qualcomm Atheros AR813x/815x
https://github.com/al3xtjames/AtherosL1cEthernet

# Atheros(R) AR81(31/32/51/52/61/62/71/72) PCI-E
# 适用于10.7-10.8
https://www.insanelymac.com/forum/topic/284119-experimental-atheros-ar813132515261627172-driver-for-107108/
```

也可尝试使用ALXEthernet。

#### Aquantia

Aquantia有线网卡驱动下载链接如下。

```
https://www.insanelymac.com/forum/topic/330614-aquantia-10-gb-ethernet-support-thread-10132-upwards/
https://www.insanelymac.com/forum/topic/330614-marvell-aquantia-10-gb-ethernet-support-thread/
```

#### 无实际网卡

因为Mac App Store、iCloud、FaceTime和iMessage的正常工作要求在en0处具有内置以太网，因此，若无有线网卡，需将NullEthernet.kext放到Clover的kexts以模拟出一个有线网卡设备。下载链接如下。

```
https://bitbucket.org/RehabMan/os-x-null-ethernet/downloads/
```

#### 网络端口重置

若以太网端口不在en0，则需进入网络偏好设置，删除所有接口并应用。

然后删除`/Library/Preferences/SystemConfiguration/NetworkInterfaces.plist`，重新启动后进入网络偏好设置，重新添加网络端口。

#### 有线网卡内建

在Clover的Devices选项卡中选择Properties，添加一个新设备，路径为通过Hackintool找到的有线网卡设备，并添加条目built-in，数值为01，类型为DATA，重启即可。

如果用的是NullEthernet.kext，则打开Maciasl，复制以下内容并保存为SSDT-RMNE.aml，然后放入Clover的ACPI/patched中即可。

```
DefinitionBlock ("", "SSDT", 2, "RehabM", "RMNE", 0x00001000)
{
    Device (RMNE)
    {
        Name (_ADR, Zero)
        Name (_HID, "NULE0000")
        Name (MAC, Buffer (0x06)
        {
             0x11, 0x22, 0x33, 0x44, 0x55, 0x66
        })
        Method (_DSM, 4, NotSerialized)
        {
            If ((Arg2 == Zero))
            {
                Return (Buffer (One)
                {
                     0x03
                })
            }

            Return (Package (0x0A)
            {
                "built-in", 
                Buffer (One)
                {
                     0x00
                }, 

                "IOName", 
                "ethernet", 
                "name", 
                Buffer (0x09)
                {
                    "ethernet"
                }, 

                "model", 
                Buffer (0x15)
                {
                    "RM-NullEthernet-1001"
                }, 

                "device_type", 
                Buffer (0x09)
                {
                    "ethernet"
                }
            })
        }
    }
}
```

#### 免驱卡

免驱卡列表如下。

```
## Aquantia Series
# AppleEthernetAquantiaAqtion.kext
# 可能需要在Linux/Windows更新固件，保证Mac支持
pci1d6a,1    = Aquantia AQC107
pci1d6a,d107 = Aquantia AQC107
pci1d6a,7b1  = Aquantia AQC107
pci1d6a,80b1 = Aquantia AQC107
pci1d6a,87b1 = Aquantia AQC107
pci1d6a,88b1 = Aquantia AQC107
pci1d6a,89b1 = Aquantia AQC107
pci1d6a,91b1 = Aquantia AQC107
pci1d6a,92b1 = Aquantia AQC107
pci1d6a,c0   = Aquantia AQC113
pci1d6a,4c0  = Aquantia AQC113

## Intel Series
# AppleIntel8254XEthernet.kext
pci8086,1096 = Intel 80003ES2LAN
pci8086,100f = Intel 82545EM
pci8086,105e = Intel 82571EB/82571GB

# AppleIntelI210Ethernet.kext
pci8086,1533 = Intel I210
pci8086,15f2 = Intel I225LM (Added in macOS 10.15)

# Intel82574L.kext
pci8086,104b = Intel 82566DC
pci8086,10f6 = Intel 82574L

## Broadcom Series
# AppleBCM5701Ethernet.kext
pci14e4,1684 = Broadcom BCM5764M
pci14e4,16b0 = Broadcom BCM57761
pci14e4,16b4 = Broadcom BCM57765
pci14e4,1682 = Broadcom BCM57762
pci14e4,1686 = Broadcom BCM57766
```


### 无线网卡

#### Atheros

本机无线网卡为Atheros AR9565，可用驱动由corecapture.kext、CoreCaptureResponder.kext和IO80211Family.kext组成，下载链接如下。

```
http://www.mediafire.com/file/2rjm76vro8ha28l/9565.zip/file
```

对于macOS 10.14，把它们放入Clover的kexts中，重启电脑后无线网卡可用。

<details>
<summary>【进阶】更高版本系统</summary>

上述kexts在Catalina中需要放到SLE才能正常工作，在Big Sur中已不适用。Big Sur中需要使用HS80211Family.kext和AirPortAtheros40.kext，下载网站如下。

```
https://www.longzc.cn/index.php/archives/330
```

在Catalina中，也可尝试以下kexts。

```
https://github.com/tj320442/AR9565-DW1707-macOS-10.15-Catalina
https://gitee.com/i320442/AR9565_DW1707/tree/master
```
</details>

对于AR946X（AR9462&AR9463）、AR9485、AR9565，也可尝试ATH9KFixup。

```
https://github.com/chunnann/ATH9KFixup
https://www.olarila.com/topic/9229-guide-wifi-atheros-ar9565-ar9462-ar9463-ar9485-on-mojave-and-catalina/
```

对于AR242x、AR542x、AR5416、AR5418、AR9280-AR5BHB92、AR9285-AR5B95、AR9287-AR5B97、AR9380-AR5BXB112，可尝试High Sierra的IO80211Family。

```
https://github.com/khronokernel/IO80211-Patches/blob/main/10.13.6-High-Sierra-Kexts/IO80211HighSierra.kext.zip
```

<details>
<summary>【过时】低版本系统</summary>

对于AR5B95/195/97/197，在High Sierra中可用以下kext。下载后解压并将kexts/ProbookAtheros.kext放置到引导器即可。

```
https://github.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/archive/master.zip
```
</details>

#### Intel

可尝试Itlwm，支持10.13及更高版本。注意应当使用itlwm.kext或AirportItlwm.kext，两者不能同时使用。推荐使用itlwm.kext。

```
https://github.com/OpenIntelWireless/itlwm
```

支持列表如下。

```
https://openintelwireless.github.io/itlwm/Compat.html
```

该kexts会使Intel无线网卡识别为有线网卡，因此需要配合HeliPort客户端使用。

```
https://github.com/OpenIntelWireless/HeliPort
```

<details>
<summary>【进阶】使用AirportItlwm</summary>

若使用AirportItlwm，则需要开启安全启动，具体可查看黑苹果的进阶操作中OpenCore的相关处理方法。
</details>

#### Broadcom

可尝试AirportBrcmFixup，适用于10.10及更高版本，链接如下。

对于DW1820A/DW1830/DW1560，需添加启动参数brcmfx-country=#a和brcmfx-aspm。安装前先于BIOS中禁用WLAN/WIFI和Bluetooth，待安装系统成功后再行开启。

对于DW1820A，还需要在config.plist添加以下设备属性。如果想体验Sidecar/Apple Watch解锁功能，compatible可为pci14e4,43a0或者pci14e4,4353，以便驱动AirPortDriverBrcmNIC并开启相应功能。

| Properties Key |           Properties Value          | Value Type |
|----------------|-------------------------------------|------------|
| AAPL,slot-name | WLAN                                | STRING     |
| compatible     | pci14e4,4353                        | STRING     |
| device_type    | Airport Extreme                     | STRING     |
| model          | DW1820A (BCM4350) 802.11ac Wireless | STRING     |
| name           | Airport                             | STRING     |

如果插上网卡后进入系统直接卡住，可添加引导参数-brcmfxoff以暂时跳过网卡驱动的加载。

```
https://github.com/acidanthera/AirportBrcmFixup
```

<details>
<summary>【注意】BCM94350ZAE芯片组</summary>

BCM94350ZAE芯片组在macOS中不正确支持电源管理，因此需要通过属性注入禁用。在引导器的设备部分添加无线网卡设备，并添加以下属性。

|       属性       | 类型 | 值 |
|------------------|------|----|
| pci-aspm-default | Data | 00 |
</details>

<details>
<summary>【进阶】AirportBrcmFixup与BrcmWLFixup</summary>

BrcmWLFixup已被整合到AirportBrcmFixup。
</details>

<details>
<summary>【进阶】OC引导</summary>

对于OpenCore，kext注入顺序为AirportBrcmFixup-AirportBrcmFixup/Contents/Plugins/AirPortBrcm4360_Injector-AirportBrcmFixup/Contents/Plugins/AirPortBrcmNIC_Injector。
</details>

对于BCM94352z/DW1560，需使用AirportBrcmFixup和BrcmPatchRAM。BrcmPatchRAM链接如下。该方法适用于10.11至10.14系统。

```
https://github.com/acidanthera/BrcmPatchRAM
```

若蓝牙失效，则将BrcmFirmwareData.kext、BrcmPatchRAM2.kext、AirportBrcmFixup.kext复制到/Library/Extensions目录下，以解决睡眠唤醒后可能引起的蓝牙失效的问题。重启前需要重建系统的缓存。

也可尝试BroadcomWiFiInjector。

<details>
<summary>【进阶】OC引导</summary>

对于OpenCore，kext注入顺序为Injector-Data-RAM。
</details>

#### Realtek

对于RTL8192CU，可采用以下链接。

```
https://drive.google.com/file/d/1ZtdMqlvKBbHULJhl1u9omuLOy6j0vx48/view
```

#### 免驱卡

列表如下。

|      无线网卡型号      |        蓝牙型号        |   连接器型号   |                                    使用的Mac产品型号                                   |
|------------------------|------------------------|----------------|----------------------------------------------------------------------------------------|
| BCM943602CDP           | 20703A1                | U.FL Connector | iMac16,x</br>iMac17,1</br>iMac18,x                                                     |
| BCM94360CD             | 20702B0                | U.FL Connector | iMac14,x</br>iMac15,x</br>MacPro6,1                                                    |
| BCM94331CD             | BRCM20702（05AC:828b） | U.FL Connector | iMac13,x                                                                               |
| BCM94360CS2            | BRCM20702（05AC:821f） | MHF4 Connector | MacBookAir5,x</br>MacBookAir6,x</br>MacBookAir7,x                                      |
| BCM943224PCIEBT        |                        |                |                                                                                        |
| BCM943602CS            | 20703A1                | MHF4 Connector | MacBookPro12,x                                                                         |
| BCM94360CS             | 20702B0                | MHF4 Connector | Macmini7,x</br>MacBookPro11,x                                                          |
| BCM94360CSAX           | BRCM20702（05AC:828c） | MHF4 Connector | MacBookPro10,x                                                                         |
| BCM94350               | 4350C1                 | MHF4 Connector | MacBook8,1                                                                             |
| BCM94350               | 20703A2                | MHF4 Connector | MacBookPro13,x                                                                         |
| BCM94350               | 4350                   | MHF4 Connector | MacBookPro14,x                                                                         |
| BCM4364                | 4364B0                 |                | iMac19,x</br>Macmini8,1</br>MacBookPro15,x</br>iMacPro1,1 - 4364</br>MacPro7,1- 4364B3 |
| BCM4355                |                        |                | MacBookAir8,1                                                                          |
| **以下为传统无线网卡** |                        |                |                                                                                        |
| BCM4328                |                        |                | iMac5,1-9,1</br>MacBook3,1-4,1</br>MacBookAir1,1-2,1                                   |
| BCM4321                |                        |                | MacPro2,1</br>Macmini4,1                                                               |
| BCM4322                |                        |                | MacBook5,1</br>MacBookPro5,1 and 7,1</br>MacBookAir3,1-5,1</br>MacPro5,1               |
| BCM43224               |                        |                | MacBook6,1</br>MacBookPro6,1                                                           |
| BCM4331                |                        |                | Macmini5,x</br>MacBookPro8,x-10,x                                                      |
| AR242X/AR542X          |                        |                | MacBook1,1</br>Macmini1,1-2,1                                                          |
| AR5418                 |                        |                | MacBook2,1                                                                             |
| AR928X                 |                        |                | iMac10,1-11,x</br>MacPro3,1                                                            |
| AR93XX                 |                        |                | iMac12,x                                                                               |

#### 其它

对于MT7610，可使用以下kext。

```
https://d86o2zu8ugzlg.cloudfront.net/mediatek-craft/drivers/MT7612_7610U_D5.0.1.25_SDK1.0.2.18_UI5.0.0.27_20151209.zip
```

对于RT5370，可使用以下kext。

```
https://d86o2zu8ugzlg.cloudfront.net/mediatek-craft/drivers/RTUSB_D2870-4.2.9.2_UI-4.0.9.6_2013_11_29.zip
```

#### 替代方法

对于无解的网卡，可以更换网卡、购买黑苹果USB网卡或者将手机作为热点。

USB网卡可尝试以下驱动。

```
https://github.com/chris1111/WirelessAdapterCloverBigSur
https://github.com/chris1111/Wireless-USB-Adapter-Clover
https://github.com/chris1111/Wireless-USB-OC-Big-Sur-Adapter
https://github.com/chris1111/USB-Wireless-Utility
https://github.com/chris1111/WIFI-Dlink-Catalina-Panel-V2
```

对于iPhone用户，将手机接入电脑，手机开启个人热点功能，即可使用手机热点。对于Android用户，可安装`hoRNDIS`，然后将手机连接到电脑，开启安卓手机的USB网络共享即可。下载链接如下。

```
https://github.com/jwise/HoRNDIS
```

### 声卡

#### 通过AppleALC驱动

##### 寻找Layout ID

保证系统SLE下有AppleHDA.kext，在Clover的kexts文件夹中放入AppleALC.kext。注意，该kext不能与VoodooHDA、RealtekALC、CloverALC、HDA Blocker、HDAEnabler1/2/3共用。下载链接如下。

```
https://github.com/acidanthera/AppleALC/releases
```

打开Hackintool，切换到Audio，通过下拉列表可查看该硬件支持的Layout ID。在启动参数中添加以下参数，其中#为所查询到的Layout ID之一。

```
alcid=#
```

若为Windows/Linux与macOS双引导，则打开Clover的config.plist，在Devices选项卡勾选Audio项下的ResetHDA选项。

重启后检查声卡是否被驱动，可在终端运行以下命令。若三者都存在，则驱动成功。

```
kextstat | grep -E "AppleHDA|AppleALC|Lilu"
```

若无声，则可更换不同的Layout ID。本机使用的Layout ID为12。打开IORegistryExplorer并搜索HDEF，若存在该设备，其下有AppleHDAController，右侧属性中的alc-layout-id不是修补前默认的07000000，且包含AppleHDAInput设备，则AppleALC已成功修补。

如果睡眠后机器无声，则还需要在Clover的kexts中放入CodecCommander.kext。注意，尽管Hackintool提示该kexts已被合并到AppleALC中，但不放置时仍会出现问题。

```
https://github.com/Sniki/EAPD-Codec-Commander
```

##### 写入Layout ID

确保该Layout ID可用后，可将该配置写入Clover的配置文件中。打开Hackintool，切换到Audio，通过下拉列表选择Layout ID。切换到Intel-Patch，选择Devices/Properties，勾选Auto Detect Changes、Audio，点击Generate Patch生成声卡驱动补丁。完成后保存以替换。

也可手动生成设备信息。打开Clover的config.plist，在Devices选项卡下选择Properties。

先在左侧栏添加声卡的设备路径。可在Hackintool中查找，也可通过gfxutil，命令如下。

```
gfxutil -f HDEF
gfxutil -f HDAS
gfxutil -f HDAU
```

然后右侧栏添加以下条目即可。

| Properties Key | Properties Value | Value Type |
|----------------|------------------|------------|
| alc-layout-id  | 21               | NUMBER     |
| hda-gfx        | onboard-1        | STRING     |
| AAPL,slot-name | Internal         | STRING     |

<details>
<summary>【进阶】十进制与十六进制</summary>

若将alc-layout-id设置为Data类型，则为十六进制模式，且遵循小端规则。如256为FF010000。
</details>

##### 实现顺序

对于AppleALC，指定Layout ID的优先级顺序为启动参数`alcid=#`->配置文件Device Properties中的alc-layout-id属性（仅适用Apple硬件）->配置文件Device Properties中的layout-id属性（适用Apple/非Apple硬件）。

##### 常见问题

<details>
<summary>【进阶】对于OC</summary>

###### 同一布局在Clover起作用而OpenCore不起作用

一般是由于IRQ冲突，可尝试使用SSDTTime中的SSDT-HPET热补丁，链接如下。

```
https://github.com/corpnewt/SSDTTime
```

###### 10.15中由于电源状态更改导致的kernel panic

在OpenCore的配置文件中设置Kernel-Quirks-PowerTimeoutKernelPanic为True。
</details>

###### AppleALC工作不一致

由于硬件没有及时初始化，可能会导致没有声音输出。添加以下启动参数即可，注意ALC延迟不能超过3000毫秒。

```
alcdelay=1000
```

或在设备属性中添加以下项。

| Properties Key | Properties Value | Value Type |
|----------------|------------------|------------|
| alc-delay      |             1000 | NUMBER     |

###### 双声卡时无声

需要让AppleALC忽略外部音频控制器。在外部音频控制器的设备属性中添加以下项即可。

| Properties Key | Properties Value | Value Type |
|----------------|------------------|------------|
| external-audio |               01 | Data       |

###### 从Windows重启到Mac后无声

可添加启动参数`alctsel=1`，或在设备属性中添加以下项。

| Properties Key | Properties Value | Value Type |
|----------------|------------------|------------|
| alctsel        |         01000000 | Data       |

#### 通过VoodooHDA驱动

在AMD上运行AppleALC可能会不起作用，则可使用VoodooHDA。下载kext并放到Clover中即可，链接如下。

```
https://sourceforge.net/projects/voodoohda/
https://github.com/chris1111/VoodooHDA-2.9.2-Clover-V14/releases
```

#### 插孔检测

使用JackFix即可，支持ResetHDA和3.5mm耳机接口类型切换。

```
https://github.com/fewtarius/jackfix
```

### 键盘与鼠标

#### 驱动

对于一般的PS2键盘，在Clover的kexts放入`VoodooPS2Controller.kext`，重启即可驱动。下载链接如下。

```
# 10.11及以上系统
https://bitbucket.org/RehabMan/os-x-voodoo-ps2-controller/downloads/

# 10.6及以上系统
https://github.com/acidanthera/VoodooPS2
```

对于MSI GK-701键盘，可用以下kext。

```
https://github.com/osy/GK701HIDDevice
```

#### 键位映射

安装`Karabiner Elements`，链接如下。

```
https://github.com/pqrs-org/Karabiner-Elements
```

打开后选择Complex Modifications，点击Add rule-Import more rules from the Internet，在网页中搜索并安装`PC-Style Shortcuts`、`PC-Style Modifiers`、`Adobe Photoshop`，并在添加的类别上点击Enable All，完成键位映射调整。

### USB

USB3端口为九针，USB2端口为四针。

#### 端口限制解除补丁

macOS规定USB端口的数量应少于15个，其中一个USB3.0的接口应按两个端口的配额计算。若端口数量大于15个，可能会导致系统无法启动，需用以下kexts补丁解除，在引导器的config.plist中添加即可。

注意，完成以下端口定制后，应当及时取消该补丁。

##### El Capitan

```
Comment: change 15 port limit to 26
Name: AppleUSBXHCIPCI
Find: 83BD8CFE FFFF10
Replace: 83BD8CFE FFFF1B
```

##### Sierra

```
Comment: Port limit increase
Name: com.apple.driver.usb.AppleUSBXHCI
Find: 83BD74FF FFFF10
Replace: 83BD74FF FFFF1B
```

或使用以下补丁。

```
Comment: change 15 port limit to 26
Name: AppleUSBXHCIPCI
Find: 83BD74FF FFFF10
Replace: 83BD74FF FFFF1B
```

##### High Sierra

对于10.13.6，应使用以下补丁。

```
Comment: USB 10.13.6+ by PMHeart
Name: com.apple.driver.usb.AppleUSBXHCI
Find: 837D880F 0F83A704 0000
Replace: 837D880F 90909090 9090
```

对于10.13.4-10.13.5，应使用以下补丁。

```
Comment: USB 10.13.4+ by PMHeart
Name: com.apple.driver.usb.AppleUSBXHCI
Find: 837D940F 0F839704 0000
Replace: 837D940F 90909090 9090
```

对于10.13-10.13.3，应使用以下补丁。

```
Comment: change 15 port limit to 24
Name: com.apple.driver.usb.AppleUSBXHCIPCI
Find: 837D8C10
Replace: 837D8C1B
```

##### Mojave

对于10.14.5-10.14.6，应使用以下补丁。

```
Comment: USB Port Limit Patch 1 PMHeart/DalianSky
Name: com.apple.iokit.IOUSBHostFamily
Find: 83FB0F0F
Replace: 83FB3F0F

Comment: USB Port Limit Patch 2 PMHeart/DalianSky
Name: com.apple.iokit.IOUSBHostFamily
Find: 83E30FD3
Replace: 83E33FD3

Comment: USB Port Limit Patch 3 PMHeart/DalianSky
Name: com.apple.driver.usb.AppleUSBXHCI
Find: 83FB0F0F
Replace: 83FB3F0F

Comment: USB Port Limit Patch 4 PMHeart/DalianSky
Name: com.apple.driver.usb.AppleUSBXHCI
Find: 83FF0F0F
Replace: 83FF3F0F
```

对于10.14.4，应使用以下补丁。

```
Comment: USB Port Limit Patch 1 ©PMHeart
Name: com.apple.iokit.IOUSBHostFamily
Find: 83FB0F0F 870B0400 00
Replace: 83FB3F0F 870B0400 00

Comment: USB Port Limit Patch 2 ©PMHeart
Name: com.apple.driver.usb.AppleUSBXHCI
Find: 4183FF0F 0F839404 0000
Replace: 4183FF3F 0F839404 0000

Comment: USB Port Limit Patch 3 ©PMHeart
Name: com.apple.iokit.IOUSBHostFamily
Find: 83E30FD3 E34109DF
Replace: 83E33FD3 E34109DF
```

对于10.14-10.14.3，应使用以下补丁。

```
Comment: Port limit increase (Ricky)
Name: com.apple.driver.usb.AppleUSBXHCI
Find: 83FB0F0F 838F0400 00
Replace: 83FB0F90 90909090 90
```

##### Catalina

对于10.15-10.15.1，应使用以下补丁。

```
Comment: USB port limit patch #1 10.15.x modify by DalianSky(credit ydeng)
Name: com.apple.iokit.IOUSBHostFamily
Find: 83FB0F0F
Replace: 83FB3F0F

Comment: USB Port limit patch #2 10.15.x modify by DalianSky
Name: com.apple.driver.usb.AppleUSBXHCI
Find: 83F90F0F
Replace: 83F93F0F
```

#### 端口定制

在Clover下放置USBInjectAll.kext，下载链接如下。

```
https://bitbucket.org/RehabMan/os-x-usb-inject-all/downloads/
```

确保cofig.pilst的ACPI更名中已应用EHC1->EH01、EHC2->EH02以及XHCI/XHC1->XHC_补丁。然后通过以下方法之一处理。

<details>
<summary>【进阶】USBInjectAll适用范围及驱动原理</summary>

USBInjectAll在桌面版Skylake及更新平台上无需使用，但在Coffee Lake及更旧平台的笔记本上则推荐使用。AsRock主板也推荐使用。注意，该kext完全不支持AMD CPU，需要10.11及以上版本。

USBInjectAll.kext以数据驱动方式进行编码。在kext代码本身中没有任何硬编码，所有数据都包含在Info.plist中。USBInjectAll.kext启动时，会在EH01/EH02/XHC或连接到EH01/EH02端口1的内部集线器上进行匹配，查询Info.plist中与它所连接的设备相关的配置数据，并注入找到的数据。
</details>

##### 通过Hackintool

打开Hackintool，点击USB，确保芯片组已被正确识别。把所有端口删除后刷新，然后分别取USB3与USB2的可移动设备对每一个接口进行插拔，每插拔一次设备将出现一个条目的改变，记录对应端口名称及USB类型，如下表所示。注意，TypeC接口需要正反各插拔一次。

注意，USB2（HSxx）占用一条USB线路，USB3、TypeC、TypeC+Sw（SSxx）占用两条USB线路。Mac最多支持占用15条USB线路，若超过则需要取舍。

|                设备类型                | 端口类型 |
|----------------------------------------|----------|
| 永久连接设备的USB端口（如蓝牙）        | Internal |
| 与USB3端口相连的HSxx端口（USB2）       | USB3     |
| 内部集线器（通常连接到端口PR11和PR21） | Internal |
| TypeC正反插端口一致                    | TypeC+Sw |
| TypeC正反插端口不一致                  | TypeC    |

完成后导出，将SSDT-EC.aml、SSDT-UIAC.aml和SSDT-USBX.aml放到Clover的ACPI/patched下。或将SSDT-EC.aml和USBPorts.kext分别放置到ACPI/patched和kexts/Other下。若放置的是SSDT，则需保留USBInjectAll.kext，若为SSDT+kext则需删除。

重启后若需检测是否成功，可插入USB3.0设备，通过系统报告查看速率是否为5G/s。或使用IOregistryExplorer，搜索XHC，可查看所有端口是否都已正常工作。

##### 通过USBMap

打开终端并运行以下命令以打开脚本。

```
git clone https://github.com/corpnewt/USBMap
cd USBMap
chmod +x USBMap.command
```

脚本打开后会核查USBInjectAll是否被正确加载、USB控制器是否被正确识别。脚本需要USBInjectAll的版本在0.70以上。若已完成放置但无法识别，则可能还需要XHCI_unsupported.kext。

若端口数量大于15个，则需要应用端口解除补丁或在脚本主菜单上选择`S. Exclude SSxx Ports`或`H. Exclude HSxx Ports`端口以禁用SSxx（一般为USB3.0）或HSxx（一般为USB2.0）端口，完成后重启。若需要取消禁用，则选择`C. Clear Exclusions`。

选择`D. Discover Ports`，脚本将读取默认USB列表。依次将每个端口用USB设备插拔，过程与使用Hackintool相同。每发现新的端口会有提示，直接忽略即可。完成后按`Q`并回车，返回主菜单。

选择`P. Edit Plist & Create SSDT/Kext`，可以看到刚才所识别的结果。需根据实际情况修改端口类型，数字代号与端口类型对应关系如下。设置要求与使用Hackintool一致。

|    数字    |                          含义                          |
|------------|--------------------------------------------------------|
| 0 (0x0)    | （USB2.0）Type A connector                             |
| 1          | Mini-AB connector                                      |
| 2          | ExpressCard                                            |
| 3 (0x3)    | （USB3.0）USB 3 Standard-A connector                   |
| 4          | USB 3 Standard-B connector                             |
| 5          | USB 3 Micro-B connector                                |
| 6          | USB 3 Micro-AB connector                               |
| 7          | USB 3 Power-B connector                                |
| 8          | Type C connector - USB2-only                           |
| 9 (0x9)    | （TypeC+Sw）Type C connector - USB2 and SS with Switch |
| 10         | Type C connector - USB2 and SS without Switch          |
| 11-254     | Reserved                                               |
| 255 (0xFF) | （Internal）Proprietary connector                      |

若需要将编号为5和7的端口改为USB2.0接口，则输入以下命令并回车。

```
// T表示现在要更改端口的类型（Type），0表示端口类型
T:5,7:0
```

也可直接用plist编辑器打开脚本编辑，一般在用户目录/USBMap/Scripts中。

设置完成后可选择`K. Build USBMap.kext`或`S. Build SSDT-UIAC`，其中第一种需把生成的kext复制到Clover的kexts目录下且删除USBInjectAll，而第二种需把生成的SSDT复制到Clover的ACPI/patched下且保留USBInjectAll。推荐第二种。

注意，在按下创建SSDT之前，可以调节SSDT的形式，默认为三个SSDT，可设置为一个SSDT。生成的所有文件都在USBMap/Results中。

##### 通过SSDT

打开IORegistryExplorer并查找XHC、EHC、EUSB或USBE，查看端口情况。

若设备不为XHC/EHC，则需要先在Clover中写入重命名。以设备为XHC1为例，需要change XHC1 to XHC_重命名，即58484331->5848435F。

打开MaciASL并新建文件，复制以下代码模版。其中8086_a12f需替换为USB总线的`VendorID_DeviceID`，可在关于本机-硬件报告的USB一项查看，如Device ID为0xa2af，Vendor ID为0x8086，则应当修改为8086_a2af。

"ports"以下的大括号需填写所有的端口，其中数字255表示Internal，10表示正反插时端口不同的USBC，9表示正反插时端口相同的USBC，3表示USB3，0表示USB2。

`"port", Buffer() { 0xNN, 0, 0, 0 },`中的0xNN表示端口地址，可在IORegistryExplorer中点击相应端口并查找Data，查看port一项即可。`"port-count", Buffer() { 0xNN, 0, 0, 0},`中的0xNN应当修改为使用的最高SS端口地址。

注意，SS端口的地址开始于最后一个HS端口地址之外。因此HS地址为`0x01，0，0，0`的物理USB端口将在`0x11，0，0，0`处具有等效的SS端口。

```
DefinitionBlock ("SSDT-USB.aml", "SSDT", 1, "sample", "USBFix", 0x00003000)
{
    Device(UIAC)
    {
        Name(_HID, "UIA00000")
        Name(RMCF, Package()
        {
            // 修改为VendorID_DeviceID
            // 以下填写所有的端口
            "8086_a12f", Package()
            {
                // 0xNN修改为使用的最高SS端口地址
                "port-count", Buffer() { 0xNN, 0, 0, 0},
                "ports", Package()
                {
                    "HS01", Package()
                    {
                        // 0-USB2，3-USB3，255-Internal
                        "UsbConnector", 255,
                        // 0xNN修改为该端口地址
                        "port", Buffer() { 0xNN, 0, 0, 0 },
                    },

                    "SS01", Package()
                    {
                        "UsbConnector", 3,
                        "port", Buffer() { 0xNN, 0, 0, 0 },
                    },
                },
            },
        })
    }
}
```

完成后保存文件为SSDT_USB.aml，并放置在引导器的ACPI部分。重启系统后打开IORegistryExplorer，检查端口是否正确显示，其中小三角形表示插入的设备。

<details>
<summary>【进阶】对于ASUS 100系列的处理</summary>

该系列主板也可不使用USBInjectAll，直接使用SSDT。提取主机SSDT并打开包含xh_rvp的文件，开头修改为如下。

```
DefinitionBlock ("SSDT-4", "SSDT", 2, "INTEL", "xh_rvp08", 0x00000000)
```

在`Name (USSD, Package (0x10)`下定义了所有的端口，其中每一行代表一个端口，One表示启用，Zero表示禁用。同理，在`Name (UHSD, Package (0x10)`下，One表示活动，Zero表示非活动。

禁用端口需要修改_UPC的返回值。以HS11为例，源代码如下。

```
Scope (\_SB.PCI0.XHC.RHUB.HS11)
        {
            Method (_UPC, 0, NotSerialized)  // _UPC: USB Port Capabilities
            {
                Return (GUPC (One))
            }

            Method (_PLD, 0, NotSerialized)  // _PLD: Physical Location of Device
            {
                Return (GPLD (DerefOf (Index (UHSD, 0x0A)), 0x0B))
            }
        }
```

修改如下。

```
Scope (\_SB.PCI0.XHC.RHUB.HS11)
        {
            Method (_UPC, 0, NotSerialized)  // _UPC: USB Port Capabilities
            {
                Return (GUPC (Zero))
            }

            Method (_PLD, 0, NotSerialized)  // _PLD: Physical Location of Device
            {
                Return (GPLD (DerefOf (Index (UHSD, 0x0A)), 0x0B))
            }
        }
```

完成后保存SSDT为SSDT-4.aml，放置到Clover的ACPI/patched目录下。Clover需要将该SSDT与当前的SSDT合并，并将修改部分替换，该工作被称为Automerge。在r4428及更新版本，Automerge已被正确设置，在旧版本则需要以文本方式打开config.plist，并添加以下内容。

若放置了USBInjectAll，则将其删除。

```
<dict>
    <key>ACPI</key>
    <dict>
        <key>AutoMerge</key>
        <true/>
        <key>DSDT</key>
        <dict>
...
```
</details>

#### 修复唤醒断线

在Clover的kexts文件夹放入USBPower.kext，下载链接如下。

```
https://blog.xjn819.com/wp-content/uploads/2019/10/USBPower.kext_.zip
```

在kext上右键选择显示包内容，打开Contents/Info.plist，展开IOKitPersonalities_x86_64，将iMac19,1改成正在使用的机型，保存并重启即可。

#### 修复USB导致的关机

下载以下文件，放置到引导器的ACPI/hotpatch部分即可。

```
https://github.com/khronokernel/Opencore-Vanilla-Desktop-Guide/blob/master/extra-files/FixShutdown-USB-SSDT.dsl
```

### 蓝牙

#### Atheros

本机蓝牙为与无线网卡Atheros AR9565共建的Bluetooth 4.0。打开以下链接并下载，直接放到Clover的kexts文件夹即可。

```
https://github.com/zxystd/AthBluetoothFirmware
```

<details>
<summary>【进阶】OC引导</summary>

对于OpenCore，放置到Kexts文件夹后需要在config.plist中添加对应条目，注意Ath3kBTInjector必须加载在Ath3kBT后面。
</details>

#### Intel

可尝试IntelBluetoothFirmware，支持10.13及更高版本。

```
https://github.com/OpenIntelWireless/IntelBluetoothFirmware
```

#### Broadcom

对于USB蓝牙，可尝试BrcmPatchRAM。

```
https://github.com/acidanthera/BrcmPatchRAM
```

对于DW1820A，可使用以下kexts。如果蓝牙睡眠唤醒后无法工作，需要添加引导参数bpr_probedelay=100、bpr_initialdelay=300、bpr_postresetdelay=300。

```
# 10.14及以下
https://images.daliansky.net/d/YmBXVA8q/blog/DW1820A/DW1820A_BT_for_Mojave_v2.5.5.zip

# 10.15及以上
https://images.daliansky.net/d/YmBXVA8q/blog/DW1820A/DW1820A_BT_for_Catalina_and_BigSur_v2.5.5.zip
```

<details>
<summary>【进阶】OC引导</summary>

对于OpenCore，kext注入顺序为BrcmBluetoothInjector-BrcmFirmwareData-BrcmPatchRAM3。
</details>

#### ~~启用蓝牙关闭按钮~~

已过时。

<details>
<summary></summary>

找到SLE下的IOBluetoothFamily.kext，复制到桌面后右键单击显示包内容，进入Contents/PlugIns，在BroadcomBluetoothHostControllerUSBTransport.kext上右键单击显示包内容，打开Contents/info.plist。用搜索功能搜索2652，修改idProduct和idVendor为自己的ID，注意需进行进制转换。从Windows上得到的是十六进制，需转换为十进制，可利用下面的进制转换工具。

```
http://tool.oschina.net/hexconvert/
```

将修改好的IOBluetoothFamily.kext用Kext Utility进行安装，重启即可。注意，此法可以实现蓝牙关闭，但需要从Windows重启进入Mac后才可用。
</details>

#### 冷启动与热启动

冷启动指从关机状态下进入系统，热启动指从一个系统重启至另一个系统。

少数蓝牙设备中嵌入了蓝牙所需的固件，因此它们开机即可直接使用。但是许多设备依靠固件上载器才能正常运行，此过程中，系统启动蓝牙设备的电源，固件上传器检测到该设备已打开电源，然后将固件发送（上传）到缓冲区中。

由于Mac无法加载相关蓝牙固件，即使设备被正确识别，也无法与任何其他外围设备配对。热启动时，Windows/Linux已完成固件上传，重启时缓冲区固件仍存在，因此蓝牙能够起作用。而冷启动时将重置蓝牙设备，导致上载固件的丢失。

#### 蓝牙无法驱动的替代方案

可通过Linux虚拟机完成蓝牙固件上传操作。

从Clover的kexts文件夹删除BrcmPatchRAM.kext和BTFirmwareUploader.kext。以Ubuntu为例，下载镜像后打开Vmware Fusion，新建虚拟机并选择Ubuntu系统，CD/DVD驱动器选择刚才的镜像，完成配置。

关闭虚拟机，切换到虚拟机设置页。选择`USB和蓝牙`首选项，取消选中`与Linux共享蓝牙设备`，列表中将出现一个蓝牙设备。返回主界面并点击`启动磁盘`，选择CD/DVD为启动项，退出设置并启动虚拟机。

镜像引导成功后，选择`试用Ubuntu`。待开机完成后，点击虚拟机的蓝牙选项以将蓝牙设备连接至Ubuntu。等待4-5秒钟后取消蓝牙连接，固件已由虚拟机上传完成，蓝牙将正常运行。关闭虚拟机，VMware将保存计算机状态，只要不让机器进入睡眠或重启状态，就可以使用蓝牙。

如果在睡眠/重新启动后失去了蓝牙功能，重新打开虚拟机，连接再断开蓝牙即可。

也可通过以下TinyCore虚拟机，使用方法同Ubuntu。

```
https://drive.google.com/file/d/1Ydm7Hd0d5XOKQkb02EMpm-6E-WQFiMkh/view
```

### 传感器

在Clover的kexts下放入VirtualSMC包内的`SMCLightSensor.kext`、`SMCProcessor.kext`和`SMCSuperIO.kext`即可。

### 电池

<details>
<summary>【进阶】对于Big Sur</summary>

Big Sur可能已经无须进行以下修补。
</details>

#### 环境配置

在Clover的kexts中放入VirtualSMC包的SMCBatteryManager.kext。打开Maciasl，若出现错误提示，则检查Clover的config.plist，Acpi-Fixs下所有选项都应取消勾选。若仍然不行，则换另一个版本的MaciASL。

#### 修改DSDT

##### 查找字段

打开MaciASL，正常情况下自动打开系统的DSDT。搜索`EmbeddedControl`。可能会有一到多个，注意包含EC字样的那一个，记住其名称，本机为`EC0R`。

搜索`Field ([EC名称]`，本机为`Field (EC0R`。查看Field里所有大于8的元素，全部进行记录后，逐个搜索它们的名字。若查找结果只有一处，表明此变量仅被定义但未被使用，因此可以将此字段从记录结果中删除，否则将此字段保留。记录时需注明每个字段的对应位数（16位/32位/大于32位）。

点击`Patch`，复制下列代码，确认下面Change(s)处的数字不为零后点击`Apply`-`Close`。

```
# 添加B1B2方法，用于16位字段拆分
into method label B1B2 remove_entry;
into definitionblock code_regex . insert
begin
Method (B1B2, 2, NotSerialized)\n
{\n
Return(Or(Arg0, ShiftLeft(Arg1, 8)))\n
}\n
end;

# 添加B1B4方法，用于32位字段拆分
into method label B1B4 remove_entry;
into definitionblock code_regex . insert
begin
Method (B1B4, 4, NotSerialized)\n
{\n
	Store(Arg3, Local0)\n
	Or(Arg2, ShiftLeft(Local0, 8), Local0)\n
	Or(Arg1, ShiftLeft(Local0, 8), Local0)\n
	Or(Arg0, ShiftLeft(Local0, 8), Local0)\n
	Return(Local0)\n
}\n
end;
```

<details>
<summary>【拓展】方法原理</summary>

对于B1B2，Arg0和Arg1为拆分后的两个8位寄存器。取Arg0作为低8位，将Arg1运用左移运算变成16位数据，此时它的的低8位全是0，再运用或运算拼接成完整的16位数据。B1B4同理。
</details>

<details>
<summary>【进阶】其它方法</summary>

W16B方法如下，将拆分后的两个8位寄存器Arg0和Arg1合并后写入到Arg2。

```
Method (W16B, 3, NotSerialized)
{
    Arg0 = Arg2
    Arg1 = (Arg2 >> 0x08)
}
```
</details>

16/32位的字段需要拆分成多个8位的字段，而大于32位的字段需要修改其偏移地址。

<details>
<summary>【提示】注意事项</summary>

如果某个寄存器被全局定义过，例如在根路径`\`或`\_SB`路径下的Field里面有相同名字的寄存器，那么搜索该寄存器被调用情况时应注意区分此处的调用是不是EC下的这一个，如果不是，说明此处调用使用的是全局定义，对EC没有影响，不需要记录下来。
</details>

##### 16/32位字段处理

对于16/32位的字段，需要拆分成2/4个8位字段。

以`HWAK, 16`为例。这是个16位的字段，可以拆分成两个8位的字段，分别命名为`AK00`和`AK01`。命名可以随意，但是要确保命名为4个字符，且这个命名没有出现过，如下。

```
// 拆分前
HWAK, 16

// 拆分后
AK00, 8
AK01, 8
```

然后需要写出以下类似正则表达式的代码，以替换DSDT里的字段。

```
into device label EC code_regex HWAK,\s+16, replace_matched begin AK00,8,AK01,8, end;
```

相关含义解释如下，内容均根据自己的DSDT代码替换。

|      内容      |                            含义                            |
|----------------|------------------------------------------------------------|
| EC             | 搜索EmbeddedControl，在其上方的Device（不是Field里的参数） |
| HWAK,\s+16,    | 拆分前的字段（`\s+`表示多个空格，故此句含义为搜索HWAK, 16,） |
| AK00,8,AK01,8, | 拆分后的字段                                               |

把写好的正则表达式复制到Patch里，在中间的Before/After和下面的Patch/Change两个地方都显示内容后，点击Apply-Close即完成一个变量的替换。

再以`SBCH, 32`为例。

```
// 拆分前
SBCH, 32

// 拆分后
CH00, 8
CH01, 8
CH02, 8
CH03, 8
```

正则表达式如下。

```
into device label EC code_regex SBCH,\s+32 replace_matched begin CH00,8,CH01,8,CH02,8,CH03,8 end;
```

注意，所替换的`AK00,8,AK01,8,`逗号前后均无空格。若所替换的字段为列表中的最后一个，则Patch时会提示0 change(s)，此时应该把正则表达式中的`XSN1,\s+16,`改为`XSN1,\s+16`，因最后一个字段没有逗号。

点击Compile，此时会出现报错，除Errors以外的不需要理会。对于报错内容为Object does not exist的情况，主要是替换字段名后，没有替换访问该字段的位置所导致。

双击报错信息以定位至错误位置，向上检索以找到该段代码包含在哪个method里。

对于16位的字段，使用下面的正则表达式。

```
into method label \_WAK code_regex \(HWAK, replaceall_matched begin (B1B2(AK00,AK01), end;
```

相关含义解释如下，内容均根据自己的DSDT代码替换。注意，名字首位为`_`时，需要手动添加起始符`\`，如`_WAK`应写为`\_WAK`。

|        内容       |       含义       |
|-------------------|------------------|
| `\_WAK`           | 代码对应的method |
| `\(HWAK,`         | 替换前的字段     |
| (B1B2(AK00,AK01), | 替换后的字段     |

对于32位的字段则使用下列表达式。

```
into method label GBIF code_regex \(SBCH, replaceall_matched begin (B1B4(CH00,CH01,CH02,CH03), end;
```

若出现`\_SB.PCI0.LPC.EC.HWAK`调用的特殊情况，修改替换字段即可。

```
into method label \_WAK code_regex \(\\\_SB.PCI0.LPC.EC.HWAK replaceall_matched begin \(\\_SB.B1B2(\\_SB.PCI0.LPC.EC.AK00, \\_SB.PCI0.LPC.EC.AK01) end;
```

<details>
<summary>【进阶】16/32位寄存器拆分读取/写入</summary>

修改16位寄存器拆分读取的语法如下，其中Arg0、Arg1为拆分后的两个8位寄存器名称。

```
B1B2 (Arg0, Arg1)
```

示例如下。

```
# 修改前
If ((^^PCI0.LPCB.EC0.BADC < 0x0C80))

# 修改后
If ((B1B2 (^^PCI0.LPCB.EC0.ADC0, ^^PCI0.LPCB.EC0.ADC1) < 0x0C80))
```

修改16位寄存器拆分写入的语法如下，其中Arg0、Arg1为拆分后的两个8位寄存器名称，Arg2为被写入的数值或数据对象。

```
W16B (Arg0, Arg1，Arg2)
```

示例如下。

```
# 修改前
SMW0 = Arg3

# 修改后
W16B (MW00, MW01, Arg3)
```

修改32位寄存器拆分读取的语法如下，其中Arg0、Arg1、Arg2、Arg3为拆分后的四个8位寄存器名称。

```
B1B4 (Arg0, Arg1, Arg2, Arg3)
```

示例如下。

```
# 修改前
If ((B1CH == 0x0050694C))

# 修改后
If ((B1B4 (BC0H, BC1H, BC2H, BC3H) == 0x0050694C))
```

修改32位寄存器读取的语法如下，其中Offset为原寄存器的偏移量，Length为原寄存器的长度。

```
RECB (Offset, Length)
```

示例如下。

```
# 原始定义
Offset (0x8F),
B1MA,   64,

# 修改前
IFMN = B1MA

# 修改后
IFMN = RECB (0x8F, 0x40)
```

修改32位以上寄存器写入的语法如下，其中Offset为原寄存器的偏移量，Length为原寄存器的长度，Obj为被写入的值或者数据对象。

```
WECB (Offset, Length, Obj)
```

示例如下。

```
# 原始定义
Offset (0x18),
SMPR,   8,
SMST,   8,
SMAD,   8,
SMCM,   8,
SMD0,   256,

# 修改前
SMD0 = FB4

# 修改后
WECB (0x1C, 0x0100, FB4) // 0x1C=0x18+0x04
```

</details>

##### 超过32位字段处理

先Patch下面的两段代码，其中H_EC改成计算机的Device。

```
// 改的字段挨着左括号时所用代码（读操作）
into method label RE1B parent_label H_EC remove_entry;
into method label RECB parent_label H_EC remove_entry;

into device label H_EC insert
begin
Method (RE1B, 1, NotSerialized)\n
{\n
	OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\n
	Field(ERAM, ByteAcc, NoLock, Preserve) { BYTE, 8 }\n
	Return(BYTE)\n
}\n
Method (RECB, 2, Serialized)\n
// Arg0 - offset in bytes from zero-based EC\n
// Arg1 - size of buffer in bits\n
{\n
	ShiftRight(Arg1, 3, Arg1)\n
	Name(TEMP, Buffer(Arg1) { })\n
	Add(Arg0, Arg1, Arg1)\n
	Store(0, Local0)\n
	While (LLess(Arg0, Arg1))\n
	{\n
	Store(RE1B(Arg0), Index(TEMP, Local0))\n
	Increment(Arg0)\n
	Increment(Local0)\n
	}\n
	Return(TEMP)\n
}\n
end;

// 改的字段挨着右括号时所用代码（写操作）
into method label WE1B parent_label H_EC remove_entry;
into method label WECB parent_label H_EC remove_entry;
into device label H_EC insert
begin
Method (WE1B, 2, NotSerialized)\n
{\n
	OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\n
	Field(ERAM, ByteAcc, NoLock, Preserve) { BYTE, 8 }\n
	Store(Arg1, BYTE)\n
}\n
Method (WECB, 3, Serialized)\n
// Arg0 - offset in bytes from zero-based EC\n
// Arg1 - size of buffer in bits\n
// Arg2 - value to write\n
{\n
	ShiftRight(Add(Arg1,7), 3, Arg1)\n
	Name(TEMP, Buffer(Arg1) { })\n
	Store(Arg2, TEMP)\n
	Add(Arg0, Arg1, Arg1)\n
	Store(0, Local0)\n
	While (LLess(Arg0, Arg1))\n
	{\n
	WE1B(Arg0, DerefOf(Index(TEMP, Local0)))\n
	Increment(Arg0)\n
	Increment(Local0)\n
	}\n
}\n
end;
```

<details>
<summary>【拓展】方法原理</summary>

对于左括号的代码如下。对于RECB，Arg0是原寄存器的偏移量（即Offset），Arg1是原寄存器的长度。对于RE1B，Arg0是偏移量。

RECB通过Arg1确定需要拆分的8位寄存器个数，通过While循环及偏移量自增方法调用RE1B从Field中循环读取出每个8位数据，并拼接成原始寄存器定义长度的数据返回结果。

```
Method (RE1B, 1, NotSerialized)
{
    OperationRegion (ERM2, EmbeddedControl, Arg0, One) // 作用域为EmbeddedControl，Arg0定义起始偏移量
    Field (ERM2, ByteAcc, NoLock, Preserve)
    {
        BYTE,   8 // 指定一个8位寄存器映射对应区域数据
    }

    Return (BYTE) // 返回结果
}

Method (RECB, 2, Serialized)
{
    Arg1 = ((Arg1 + 0x07) >> 0x03) // 计算Arg1除8并向上取整，位移运算更快
    Name (TEMP, Buffer (Arg1){}) // 初始化作为返回值的Buffer
    Arg1 += Arg0 // 加上偏移量，即循环终止值
    Local0 = Zero // 定义Buffer索引为0
    While ((Arg0 < Arg1)) // 进行循环，循环次数为初次计算的Arg1
    {
        TEMP [Local0] = RE1B (Arg0) // 调用RE1B依次返回8位数据
        Arg0++ // 偏移量自增
        Local0++ // 索引自增
    }

    Return (TEMP) // 返回最终结果
}
```

对于右括号的代码如下。对于WECB，Arg0是原寄存器的偏移量（即Offset），Arg1是原寄存器的长度，Arg2为被写入的数据或对象。对于WE1B，Arg0是偏移量，Arg1为从Buffer取出的一个字节数据（即8位长度数据）。

WECB通过Arg1确定需要拆分的8位寄存器个数，创建Buffer对象将Arg2转化为若干个字节的数据（一个字节等于8位），通过While循环以及偏移量自增方法调用WE1B，向Field中循环写入每个8位数据。

```
Method (WE1B, 2, NotSerialized)
{
    OperationRegion (ERM2, EmbeddedControl, Arg0, One) // EmbeddedControl为EC作用域，Arg0定义起始偏移量
    Field (ERM2, ByteAcc, NoLock, Preserve)
    {
        BYTE,   8 // 指定一个8位寄存器映射对应区域数据
    }

    BYTE = Arg1 // 将Arg1通过寄存器间接写入对应区域
}

Method (WECB, 3, Serialized)
{
    Arg1 = ((Arg1 + 0x07) >> 0x03) // 计算Arg1除8并向上取整，位移运算更快
    Name (TEMP, Buffer (Arg1){}) // 初始化作为写入值的Buffer
    TEMP = Arg2 // 将被写入的数据或对象赋值给TEMP
    Arg1 += Arg0 // 加上偏移量，即循环终止值
    Local0 = Zero // 定义Buffer索引为0
    While ((Arg0 < Arg1)) // 进行循环，循环次数为初次计算的Arg1
    {
        WE1B (Arg0, DerefOf (TEMP [Local0])) // 调用WE1B依次写入8位数据
        Arg0++ // 偏移量自增
        Local0++ // 索引自增
    }
}
```

有些笔记本的EC使用SystemMemory作用域，则EC、RE1B和WE1B的Field起始偏移量也需要加上原始定义数值，可参照如下所示代码进行修改。

```
Scope (_SB.PCI0.LPCB.EC0)
{
    OperationRegion (ERAX, SystemMemory, 0xFE708300, 0x0100)
    Field (ERAX, ByteAcc, Lock, Preserve)
    {
    ···
    Method (RE1B, 1, NotSerialized)
    {
        Local0 = (0xFE708300 + Arg0)
        OperationRegion (ERM2, SystemMemory, Local0, One)
```
</details>

计算大于32位字段的偏移量，逢八进一，从起始值往下算。以下面的代码为例子。

```
Offset (0x04),
	CMCM,   8, // 0x04
	CMD1,   8, // 0x05=0x04+1（8位是1字节）
	CMD2,   8, // 0x06
	CMD3,   8, // 0x07
	Offset (0x18), // 这里空了一些，按开头所给出的偏移量计算
	Offset (0x19),
	SMST,   8, // 0x19
	MBMN,   80, // 0x1A
	MBPN,   96, // 0x25=0x1A（上一个的起始地址）+A（80/8=10，上一个占了10个字节，16进制表示即为A）+1
	GPB1,   8, // 0x32=0x25+C（96位占了12个字节，16进制表示即为C）+1
	GPB2,   8, // 0x33
	GPB3,   8, // 0x34
	GPB4,   8, // 0x35
```

搜索DSDT中该字段被调用的地方。不同于16/32位字段的处理，超过32位的字段只需用偏移量和该字段位数代替字段本身。

若所替换字段挨着左括号，需要使用RECB，即处理读操作。以`Store(MBMN, XXXX) `改为`Store(RECB(0x1A, 80), XXXX)`为例，利用下列正则表达式进行替换，Patch即可。

```
into method label XXXX code_regex \(SBMN, replaceall_matched begin (RECB(0xA0,128), end;
```

相关含义解释如下，内容均根据自己的DSDT代码替换。

|        内容       |                 含义                |
|-------------------|-------------------------------------|
| XXXX            | 代码对应的method                    |
| `\(SBMN,`           | 替换前的字段 |
| (RECB(0xA0,128), | 替换后的字段，其中0xA0为所计算出来的偏移量，128为位数                        |

若所替换字段挨着右括号，需要使用WECB，即处理写操作。以`Store (Arg3, \_SB.PCI0.LPCB.EC0.SMD0)`改为`Store (Arg3, \_SB.PCI0.LPCB.EC0.WECB(0x1C,264,Arg3)`为例，则利用下列正则表达式进行替换。

```
into method label SMRW code_regex Store\s\(Arg3,\s\\_SB.PCI0.LPCB.EC0.SMD0\) replaceall_matched begin \\_SB.PCI0.LPCB.EC0.WECB(0x1C,264,Arg3) end;
```

##### 应用修改

再次点击Compile，确认无Error后，点击菜单File-Save As，类型选ACPI Machine Language Binary，名称为DSDT.aml。保存后复制到CLOVER/ACPI/patched，重启即可。

#### 说明

##### 正则表达式写法

16位和32位的区别在于，16位会调用B1B2方法，而32位会调用B1B4方法。因此正则表达式的基本格式如下。

```
// 16位字段
into method label [代码对应method] code_regex [替换前的字段，需要包含逗号] replaceall_matched begin (B1B2[替换后的字段，需要包含逗号] end;

// 32位字段
into method label [代码对应method] code_regex [替换前的字段，需要包含逗号] replaceall_matched begin (B1B4[替换后的字段，需要包含逗号] end;

// 特殊字段的处理（把整个地址复制进去即可）
B1B2(特殊字段1，特殊字段2)
B1B4(特殊字段1，特殊字段2，特殊字段3，特殊字段4)
```

##### 补丁结构

将前面所有Patch过的代码放到一起，即称为本机的电量补丁，示例如下。

注意，前面所有通过正则表达式的操作，其实可以直接在原文件上修改，而不必通过Patch的方式。通过Patch方式主要是便于补丁整合与传播。

```
// 字段拆分
into device label EC0 code_regex B0C3,\s+16, replace_matched begin C3HG,8,C3HF,8, end;
into device label EC0 code_regex B0SN,\s+16, replace_matched begin BSVN,8,BSVM,8, end;
into device label EC0 code_regex B1SN,\s+16 replace_matched begin SBUY,8,SBUP,8 end;

// 替换调用方法
into method label _BIX code_regex \(B0C3, replaceall_matched begin (B1B2(C3HG,C3HF), end;
into method label BIFA code_regex \(B0SN, replaceall_matched begin (B1B2(BSVN,BSVM), end;
into method label BIFA code_regex \(B1SN, replaceall_matched begin (B1B2(SBUY,SBUP), end;

// 数据处理方法
into method label B1B2 remove_entry;
into definitionblock code_regex . insert
begin
Method (B1B2, 2, NotSerialized)\n
{\n
Return(Or(Arg0, ShiftLeft(Arg1, 8)))\n
}\n
end;
```

##### Mutex置零检查及修复

###### 检查

有些机器的Mutex（互斥体，用于处理多线程同步）对象的SyncLevel（同步等级）不为0，这种情况下macOS无法正常执行多线程同步，造成的结果是电池状态等可能无法获取（如果电池相关的Method处于不同的同步等级，在macOS下会造成数据获取的异常，出现0%的情况），此时应打上Mutex置0补丁来解决。

绝大多数笔记本ACPI的Mutex都是默认置0的，但是一些联想品牌的笔记本往往有几个Mutex的SyncLevel并不是0。因此，在完成电池补丁后应检查Mutex是否属于这种情况。

在DSDT中搜索Mutex，看出现的几个对象的SyncLevel是否为0即可。

###### 修复

可通过ACPI更名的方式。以Mutex (BATM, 0x07)为例，先转换BATM为十六进制代码，得到42 41 54 4D。在前后加上完整定义的十六进制代码，最终得到01 42 41 54 4D 07，其中01代表Mutex，07代表SyncLevel的0x07。目的是使Mutex对象置0，因此更名如下。

```
Comment: Set Mutex BATM, 0x07 to 0x0
Find: 01424154 4D07
Repalce: 01424154 4D00
```

也可通过Fix Mutex with non-zero SyncLevel补丁。打开MaciASL，点击Patch，在左侧资源树中选择`_RehabMan Laptop`-`[sys]Fix Mutex with non-zero SyncLevel`，点击Apply-Close即可。

若没有该资源，则需要在偏好设置中添加补丁来源。常见补丁来源如下。

```
# _RehabMan Laptop
http://raw.github.com/RehabMan/Laptop-DSDT-Patch/master

# _OS-X-ACPI-Debug
http://raw.github.com/RehabMan/OS-X-ACPI-Debug/master

# _VoodooI2C-Patches
http://raw.github.com/alexandred/VoodooI2C-Patches/master

# Sourceforge
http://maciasl.sourceforge.net

# Gigabyte
http://maciasl.sourceforge.net/pjalm/gigabyte

# ASUS
http://maciasl.sourceforge.net/pjalm/asus

# Audio HDMI 5 Series
https://raw.github.com/toleda/audio_hdmi_5series/master

# Audio HDMI HD3000/Sandy Bridge/6 Series
https://raw.github.com/toleda/audio_hdmi_hd3000/master

# Audio HDMI HD4000/Ivy Bridge/7 Series
https://raw.github.com/toleda/audio_hdmi_hd4000/master

# Audio HDMI UEFI Audio dsdt edits - Desktop/Laptop/Intel NUC
https://raw.github.com/toleda/audio_hdmi_uefi/master

# Audio Realtek ALC injection
https://raw.github.com/toleda/audio_ALCInjection/master

# Airport PCIe Half Mini
https://raw.github.com/toleda/airport_pcie-hm/master

# Audio HDMI HD4600/Haswell/8 Series
https://raw.github.com/toleda/audio_hdmi_8series/master

# PJALM General
http://pjalm.info/repos/general/

# PJALM Graphics
http://pjalm.info/repos/graphics/

# PJALM Intel Series 6
http://pjalm.info/repos/intel6/

# PJALM Intel Series 7
http://pjalm.info/repos/intel7/

# PJALM ASUS
http://pjalm.info/repos/asus/

# PJALM Gigabyte
http://pjalm.info/repos/gigabyte/

# PJALM MSI
http://pjalm.info/repos/msi/

# PJALM ASRock
http://pjalm.info/repos/asrock/

# PJALM Zotac
http://pjalm.info/repos/zotac/

# Gigabyte
http://www.tonymacx86.com/DSDT/

# HP ProBook 4x30s
https://raw.githubusercontent.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/master

# HP Probook patch
http://raw.github.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/master
```

##### 充电/放电状态的逻辑错误

某些华硕笔记本电脑的DSDT存在逻辑错误，容量达到100％（电池充满电）时，_BST返回错误的状态。使用以下补丁程序即可。

```
into method label FBST code_regex If\s\(CHGS\s\(Zero\)\)[\s]+\{[\s]+Store\s\(0x02,\sLocal0\)[\s]+\}[\s]+Else[\s]+\{[\s]+Store\s\(One,\sLocal0\)[\s]+\} replaceall_matched begin
If (CHGS (Zero))\n
{\n
Store (0x02, Local0)\n
}\n
Else\n
{\n
Store (Zero, Local0)\n
}
end;
```

### 触控板

以下的所有操作对软件版本均有要求。MaciASL需为RehabMan编译版，IORegistryExplorer需为2.1版本。

#### 判断触控板类型

在Windows下打开设备管理器，若在人体学输入设备下存在I2C HID设备，则一般为I2C HID触摸板。查看触摸板设备的属性，若显示位置是`在 I2C HID设备 上`，则得证。否则触控板一般为PS2类型。

#### PS2触控板

用VoodooPS2Controller.kext驱动即可。

#### I2C触控板

##### 记录IRQ

在Windows下打开设备管理器，在`I2C HID设备`上右键选择属性，点击详细信息，选择`位置路径`并记录。然后切换到资源选项卡，记录IRQ后面的数字，该数字代表的是APIC Pin。本机示例如下。

```
// IRQ
0x0000006D (109)

// 位置路径，其中ETPD为触控板BIOS名称
ACPI(_SB_)#ACPI(PCI0)#ACPI(I2C1)#ACPI(ETPD)
```

也可在Mac下查看APIC Pin。打开IORegistryExplorer，右上角搜索触控板BIOS名称，本机即为ETPD，在详细页中记录IOInterruptSpecifiers的值即可。

##### 确定工作原理

I2C触控板均用VoodooI2C驱动，支持轮询模式或中断模式。

轮询模式是Voodoo的安全模式，每隔一个特定的时间扫描一次触摸板的状态，然后改变鼠标指针坐标。中断模式是触摸板在Windows/Linux等其他系统的正常工作方式。

在DSDT中定义如下。

|   定义   |                                        含义                                        |                适用范围               | 效率 |          驱动难度          |
|----------|------------------------------------------------------------------------------------|---------------------------------------|------|----------------------------|
| APIC中断 | 使用APIC控制器                                                                     | 无IOInterruptSpecifier，或APIC Pin<2F | 最高 | 能否以该模式驱动由硬件决定 |
| GPIO中断 | DSDT在SBFG中存在有效GPIO Pin，CRS方法中返回(SBFB,SBFG)，并应用启用GPIO控制器的补丁 | 有IOInterruptSpecifier且APIC Pin>2F   | 较高 | 较难                       |
| 轮询     | CRS方法中只返回SBFB或者(SBFB,SBFI)                                                 | /                                     | 较低 | 较易                       |


也就是说，对于原始DSDT，以APIC Pin为判断依据，若小于2F则默认使用APIC中断，若大于2F则默认使用GPIO控制器。但由于GPIO控制器默认不工作，因此系统会采用轮询模式，如下图所示。

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9j9syjzgdj30jg0m8jst.jpg)

<details>
<summary>【进阶】DSDT中的相关代码</summary>

找到触摸板的相关代码后，查看SBFI方法，该方法用于实现APIC中断。该方法中的数值即为APIC Pin，当APIC Pin大于2F时，可判断为轮询模式。

```
Name (SBFI, ResourceTemplate ()
{
    Interrupt (ResourceConsumer, Level, ActiveLow, ExclusiveAndWake, ,, _Y25)
    {
        0x00000000,
    }
})
```

查看SBFB方法，该方法可被轮询或中断调用。部分DSDT中不含SBFB而含I2CM，两者基本一致，I2CM相比SBFB具有更多的内容。

```
Name (SBFB, ResourceTemplate ()
{
    I2cSerialBusV2 (0x004C, ControllerInitiated, 0x00061A80,
        AddressingMode7Bit, "\\_SB.PCI0.I2C1",
        0x00, ResourceConsumer, _Y2A, Exclusive,
        )
})
```

查看SBFG方法，该方法中的数值即为GpioInt，用于中断处理。

```
Name (SBFG, ResourceTemplate ()
{
    GpioInt (Level, ActiveLow, ExclusiveAndWake, PullDefault, 0x0000,
        "\\_SB.PCI0.GPI0", 0x00, ResourceConsumer, ,
        )
        {   // Pin list
            0x0000
        }
})
```
</details>

##### 轮询模式驱动

下载VoodooI2C，按照以下规则将驱动放入Clover的kexts中（一个核心驱动+一个目标驱动）并重启。

```
# 必放核心驱动
VoodooI2C.kext

# 根据情况选择目标驱动
VoodooI2CELAN.kext - ELAN触摸板
VoodooI2CHID.kext - I2C触摸板
VoodooI2CFTE.kext - FTE触摸板
VoodooI2CSynaptics.kext - Synaptics触摸板
VoodooI2CAtmelMXT.kext - MXT触摸屏
VoodooI2CUPDDEngine.kext - UPDD多点触控引擎
```

对于小部分机型（如华硕笔记本），触控板已被驱动。若未被驱动，则需要对DSDT应用`Windows补丁`，根据出厂时随附的操作系统应用对应的补丁，一般用Windows 10 Patch。

<details>
<summary>【非必要不使用】操作系统补丁</summary>

以下方法选择一种即可。

DSDT修改法如下。

打开MaciASL，保证有VoodooI2C的补丁源。点击Patch，选择VoodooI2C下的`Windows 10 Patch`补丁，Apply-Close后保存DSDT，并将新的DSDT放入Clover文件夹的ACPI/patched下即可。

若MaciASL无法加载出补丁源，可直接在Patch界面复制以下代码内容。根据操作系统自行选择。

```
# Windows 10 DSDT Patch for VoodooI2C
into_all method code_regex If\s+\([\\]?_OSI\s+\(\"Windows\s2015\"\)\) replace_matched begin If(LOr(_OSI("Darwin"),_OSI("Windows 2015"))) end;

# Windows 8.1 DSDT Patch for VoodooI2C
into_all method code_regex If\s+\([\\]?_OSI\s+\(\"Windows\s2013\"\)\) replace_matched begin If(LOr(_OSI("Darwin"),_OSI("Windows 2013"))) end;

# Windows 8 DSDT Patch for VoodooI2C
into_all method code_regex If\s+\([\\]?_OSI\s+\(\"Windows\s2012\"\)\) replace_matched begin If(LOr(_OSI("Darwin"),_OSI("Windows 2012"))) end;

# Windows 7 DSDT Patch for VoodooI2C
into_all method code_regex If\s+\([\\]?_OSI\s+\(\"Windows\s2009\"\)\) replace_matched begin If(LOr(_OSI("Darwin"),_OSI("Windows 2009"))) end;
```

SSDT热补丁法如下。

打开MaciASL，新建文件并复制以下内容，保存为SSDT-XOSI.aml。

```
DefinitionBlock ("", "SSDT", 2, "DRTNIA", "XOSI", 0x00001000)
{
    Method (XOSI, 1, NotSerialized)
    {
        Store (Package (0x11)
            {
                "Windows 2001", 
                "Windows 2001.1", 
                "Windows 2001 SP1", 
                "Windows 2001 SP2", 
                "Windows 2001 SP3", 
                "Windows 2006", 
                "Windows 2006 SP1", 
                "Windows 2009", 
                "Windows 2012", 
                "Windows 2013", 
                "Microsoft Windows NT", 
                "Microsoft Windows", 
                "Microsoft WindowsME: Millennium Edition"
            }, Local0)
        If (_OSI ("Darwin"))
        {
            Return (LNotEqual (Ones, Match (Local0, MEQ, Arg0, MTR, Zero, Zero)))
        }
        Else
        {
            Return (_OSI (Arg0))
        }
    }
}
```

将SSDT-XOSI.aml放置在Clover文件夹的ACPI/patched目录下，然后在config.plist下添加以下改名补丁即可。

```
Comment: change _OSI to XOSI
Find: 5F4F5349
Replace: 584F5349
```
</details>

##### 中断模式驱动

###### 查看APIC Pin值

不放置VoodooI2C驱动，并应用Windows补丁。打开IORegistryExplorer，搜索前面保存的BIOS设备名称，然后定位到`IOInterruptSpecifiers`，最前面的两位数即为`APIC Pin`值。

若无IOInterruptSpecifiers项或APIC Pin值不大于`2F`，则直接跳到安装步骤，否则继续下列步骤。

###### 移除APIC中断控制器

用MaciASL打开设备的DSDT，搜索`BIOS设备名称`（此处为ETPD），定位到触控板设备的代码块下。注意，以下操作全部在触控板设备的代码块下进行，请勿跳到其他设备下的代码操作。

在触控板设备的代码块下寻找类似以下的代码。

```
Method (_CRS, 0, Serialized)  // _CRS: Current Resource Settings
{
    Name (SBFI, ResourceTemplate ()
    {
        I2cSerialBusV2 (0x0015, ControllerInitiated, 0x00061A80,
            AddressingMode7Bit, "\\_SB.PCI0.I2C1",
            0x00, ResourceConsumer, , Exclusive,
            )
        Interrupt (ResourceConsumer, Level, ActiveLow, Exclusive, ,, )
        {
            0x0000006D,
        }
    })
    Return (SBFI)
}
```

在此段代码中，需将`SBFI`改为`SBFB`，并删除以下内容。

```
Interrupt (ResourceConsumer, Level, ActiveLow, Exclusive, ,, )
{
    0x0000006D,
}
```

以上面代码为例，修改后变为如下。

```
Method (_CRS, 0, Serialized)  // _CRS: Current Resource Settings
{
    Name (SBFB, ResourceTemplate ()
    {
        I2cSerialBusV2 (0x0015, ControllerInitiated, 0x00061A80,
            AddressingMode7Bit, "\\_SB.PCI0.I2C1",
            0x00, ResourceConsumer, , Exclusive,
            )
        })
        Return (SBFB)
}
```

###### 确定触控板固定类型

在触控板的DSDT下寻找以下代码块。

```
Name (SBFG, ResourceTemplate ()
{
    GpioInt (Level, ActiveLow, ExclusiveAndWake, PullDefault, 0x0000,
        "\\_SB.PCI0.GPI0", 0x00, ResourceConsumer, ,
        )
        {   // Pin list
            0x0000
        }
})
```

若此段代码出现在设备的根目录，则称为触控板设备已经`root固定`。若出现在CRS方法中，则称为触控板设备已经`CRS固定`。如果Pin list对应非零值，称为`well-root固定`和`well-CRS固定`。若此段代码未出现，则称为触控板设备`未固定`。

若未固定，则先将以上代码段复制到设备根目录下，示例如下。复制完成后跳到GPIO固定步骤。

```
Scope (_SB.PCI0.I2C0)
{
       Device (ETPD)
       {
           Name (SBFG, ResourceTemplate ()
           {
                GpioInt (Level, ActiveLow, Exclusive, PullUp, 0x0000,
                        "\\_SB.PCI0.GPI0", 0x00, ResourceConsumer, ,
                        )
                        {   // Pin list
                            0x0000
                        }
           })
           ......
```

若为root固定或CRS固定，需在触控板代码块下查找`_CRS`方法，并确定以下代码是否存在。若存在，则证明设备已固定好，可直接跳到安装步骤，否则需继续GPIO固定步骤。

```
Return (ConcatenateResTemplate (SBFB, SBFG))
```

若为well-root固定或well-CRS固定，则直接跳到安装步骤。

###### GPIO固定

定位到代码块的_CRS方法，删除此方法的Return语句并用以下Return语句替换，以确保DSDT通知系统设备已固定好GPIO。

```
Return (ConcatenateResTemplate (SBFB, SBFG))
```

###### 驱动安装

驱动的安装包括驱动放置、禁用系统驱动、应用补丁，其中放置驱动操作与轮询模式完全一致。对于系统驱动，需禁用AppleIntelLpssI2C.kext和AppleIntelLpssI2CController.kext，方法见说明。应用补丁需应用Windows补丁和GPIO补丁。

Windows补丁的应用与轮询模式完全一致，GPIO补丁的应用提供以下两种形式。

###### 热补丁法应用GPIO补丁

在OC-little包中取`SSDT-GPIO.aml`并放置在Clover文件夹的ACPI/patched目录下，然后在config.plist下添加以下改名补丁即可。注意，在补丁无效时，可尝试删除`Tgtbridge`值。

```
Comment: change _STA to XSTA in GPI0 
Find: 5F535441
Replace: 58535441
TgtBridge: 47504930
```

###### DSDT修改法应用GPIO补丁

在MaciASL下点击Patch，选择VoodooI2C下的`GPIO Controller`和`SKL I2C Controller`补丁，Apply-Close后保存DSDT，并将新的DSDT放入Clover文件夹的ACPI/patched下即可。

若MaciASL无法加载出补丁源，可直接在Patch界面复制以下代码内容。

```
// GPI0 Controller
into method label _STA parent_label GPI0 replace_content begin
Return (0x0F)
end;


// Skylake controller patches for VoodooI2C
into_all device label I2C0 remove_entry;
into_all device label I2C1 remove_entry;
into_all device label I2C2 remove_entry;
into_all device label I2C3 remove_entry;
into_all device label I2C4 remove_entry;
into_all device label I2C5 remove_entry;

into scope label _SB.PCI0 insert begin

Device (I2C0)\n
{\n
    Name (LINK, "\\_SB.PCI0.I2C0")\n
    Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current\n
    {\n
        Return (GETD (SB10))\n
    }\n
\n
    Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0\n
    {\n
        LPD0 (SB10)\n
    }\n
\n
    Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3\n
    {\n
        LPD3 (SB10)\n
    }\n
}\n
\n\n
Device (I2C1)\n
{\n
    Name (LINK, "\\_SB.PCI0.I2C1")\n
    Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current\n
    {\n
        Return (GETD (SB11))\n
    }\n
\n
    Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0\n
    {\n
        LPD0 (SB11)\n
    }\n
\n
    Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3\n
    {\n
        LPD3 (SB11)\n
    }\n
}\n
\n\n
Device (I2C2)\n
{\n
    Name (LINK, "\\_SB.PCI0.I2C2")\n
    Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current\n
    {\n
        Return (GETD (SB12))\n
    }\n
\n
    Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0\n
    {\n
        LPD0 (SB12)\n
    }\n
\n
    Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3\n
    {\n
        LPD3 (SB12)\n
    }\n
}\n
\n\n
Device (I2C3)\n
{\n
    Name (LINK, "\\_SB.PCI0.I2C3")\n
    Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current\n
    {\n
        Return (GETD (SB13))\n
    }\n
\n
    Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0\n
    {\n
        LPD0 (SB13)\n
    }\n
\n
    Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3\n
    {\n
        LPD3 (SB13)\n
    }\n
}\n
\n
Device (I2C4)\n
{\n
    Name (LINK, "\\_SB.PCI0.I2C4")\n
    Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current\n
    {\n
        Return (GETD (SB14))\n
    }\n
\n
    Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0\n
    {\n
        LPD0 (SB14)\n
    }\n
\n
    Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3\n
    {\n
        LPD3 (SB14)\n
    }\n
}\n
\n
Device (I2C5)\n
{\n
    Name (LINK, "\\_SB.PCI0.I2C5")\n
    Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current\n
    {\n
        Return (GETD (SB15))\n
    }\n
\n
    Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0\n
    {\n
        LPD0 (SB15)\n
    }\n
\n
    Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3\n
    {\n
        LPD3 (SB15)\n
    }\n
}\n
\n
end;

into scope label _SB.PCI0.I2C0 replace_content begin

    Name (_HID, "INT3442")  // _HID: Hardware ID\n
    Method (_HRV, 0, NotSerialized)  // _HRV: Hardware Revision\n
    {\n
        Return (LHRV (SB10))\n
    }\n
\n
    Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings\n
    {\n
        Return (LCRS (SMD0, SB00, SIR0))\n
    }\n
\n
    Method (_STA, 0, NotSerialized)  // _STA: Status\n
    {\n
        Return (LSTA (SMD0))\n
    }\n
}\n
end;

into scope label _SB.PCI0.I2C1 replace_content begin

    Name (_HID, "INT3443")  // _HID: Hardware ID\n
    Method (_HRV, 0, NotSerialized)  // _HRV: Hardware Revision\n
    {\n
        Return (LHRV (SB11))\n
    }\n
\n
    Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings\n
    {\n
        Return (LCRS (SMD1, SB01, SIR1))\n
    }\n
\n
    Method (_STA, 0, NotSerialized)  // _STA: Status\n
    {\n
        Return (LSTA (SMD1))\n
    }\n
}\n
end;

into scope label _SB.PCI0.I2C2 replace_content begin

    Name (_HID, "INT3444")  // _HID: Hardware ID\n
    Method (_HRV, 0, NotSerialized)  // _HRV: Hardware Revision\n
    {\n
        Return (LHRV (SB12))\n
    }\n
\n
    Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings\n
    {\n
        Return (LCRS (SMD2, SB02, SIR2))\n
    }\n
\n
    Method (_STA, 0, NotSerialized)  // _STA: Status\n
    {\n
        Return (LSTA (SMD2))\n
    }\n
}\n
end;
into scope label _SB.PCI0.I2C3 replace_content begin

    Name (_HID, "INT3445")  // _HID: Hardware ID\n
    Method (_HRV, 0, NotSerialized)  // _HRV: Hardware Revision\n
    {\n
        Return (LHRV (SB13))\n
    }\n
\n
    Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings\n
    {\n
        Return (LCRS (SMD3, SB03, SIR3))\n
    }\n
\n
    Method (_STA, 0, NotSerialized)  // _STA: Status\n
    {\n
        Return (LSTA (SMD3))\n
    }\n
}\n
end;

into scope label _SB.PCI0.I2C4 replace_content begin

    Name (_HID, "INT3446")  // _HID: Hardware ID\n
    Method (_HRV, 0, NotSerialized)  // _HRV: Hardware Revision\n
    {\n
        Return (LHRV (SB14))\n
    }\n
\n
    Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings\n
    {\n
        Return (LCRS (SMD4, SB04, SIR4))\n
    }\n
\n
    Method (_STA, 0, NotSerialized)  // _STA: Status\n
    {\n
        Return (LSTA (SMD4))\n
    }\n
}\n
end;

into scope label _SB.PCI0.I2C5 replace_content begin

    Name (_HID, "INT3447")  // _HID: Hardware ID\n
    Method (_HRV, 0, NotSerialized)  // _HRV: Hardware Revision\n
    {\n
        Return (LHRV (SB15))\n
    }\n
\n
    Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings\n
    {\n
        Return (LCRS (SMD5, SB05, SIR5))\n
    }\n
\n
    Method (_STA, 0, NotSerialized)  // _STA: Status\n
    {\n
        Return (LSTA (SMD5))\n
    }\n
}\n
end;
```

###### 确认驱动情况

所有步骤完成后重启。若触控板未驱动或开机卡Busy timeout，则考虑更换不同的Pin list值。

对于本机而言，APIC Pin值为0x6D。

##### 特殊处理

###### 华硕笔记本

华硕笔记本的DSDT会有一个TPD0设备，该设备具有GPIO中断的模板，但并不是真实的设备。应当修补ETPD设备。

###### 三星笔记本

使用轮询模式驱动时，需在应用补丁的同时在DSDT的以下代码中删除`If (_OSI ("Windows 2012")) {`及对应的`}`，如下。

```
If (_OSI ("Windows 2012"))
{
    Scope (_SB.PCI0.I2C0.SPTP)
    {
    }

    Scope (_GPE)
    {
        Method (_L04, 0, NotSerialized)  // _Lxx: Level-Triggered GPE
        {
            Notify (\_SB.PCI0.I2C0.SPTP, 0x02)
            Notify (\_SB.PWRB, 0x02)
        }
    }

    Scope (_SB.PCI0.I2C0.ATFU)
    {
        Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
        {
            Name (SBFB, ResourceTemplate ()
            {
                I2cSerialBusV2 (0x0026, ControllerInitiated, 0x00061A80,
                    AddressingMode7Bit, "\\_SB.PCI0.I2C0",
                    0x00, ResourceConsumer, , Exclusive,
                    )
                I2cSerialBusV2 (0x0027, ControllerInitiated, 0x00061A80,
                    AddressingMode7Bit, "\\_SB.PCI0.I2C0",
                    0x00, ResourceConsumer, , Exclusive,
                    )
            })
            Return (SBFB)
        }
    }
}
```

若仍未解决，则在DSDT中进入设备SPTP的_INI方法，搜索以下代码并将其内容更改为`SHPO (Local0, One)`，如下。

```
If (LEqual (SDM0, Zero))
{
    SHPO (Local0, One)
}
```

#### 其它

对于Thinkpad T480s/L380/P52的I2C-I801设备，为ELAN触控板，可用VoodooSMBus，适用于10.14及以上系统。

```
https://github.com/VoodooSMBus/VoodooSMBus
```

对于Synaptic的I2C HID/SMBus触控板，可用VoodooRMI，适用于10.11及以上系统。

```
https://github.com/VoodooSMBus/VoodooRMI
```

对于Alps T4 USB触摸板，可用AlpsT4USB。

```
https://github.com/blankmac/AlpsT4USB
```

### TouchID

笔记本的指纹传感器一般都无法被驱动。但由于SMBIOS设置的机型具有TouchID，因此在输入密码或进行认证时，系统会等待指纹的反馈，导致键盘输入卡顿。

在Clover的kexts文件夹下放置`NoTouchID.kext`，重启后即可修复。

```
https://github.com/al3xtjames/NoTouchID/releases
```

## SMBIOS与三码设置

正确设置SMBIOS并注入正确的三码，可开启HWP功能，并正常登录iCloud等苹果服务。系统的SMBIOS支持列表可在安装盘的/System/Library/CoreServices/PlatformSupport.plist查看。

### 选择

选择SMBIOS应考虑CPU类型、GPU类型、操作系统支持、USB设备等。一般而言，应当先尽可能找到合适的CPU，然后选择仅iGPU或仅dGPU的SMBIOS，最后决定其它因素。

#### CPU

SMBIOS的CPU决定了是否能使用XCPM进行电源管理修复，以及能否开启HWP。XCPM支持的SMBIOS如下。

```
MacBook8,1+
MacBookAir6,x+
MacBookPro11,x+
Macmini7,1+
iMac14,x+
iMacPro1,1
MacPro7,1+
```

打开终端并输入以下命令以查询支持HWP的机型，在输出内容中选择台式机机型或笔记本机型。注意需挑选带HWP字样的机型，且尽可能选最新的机型，2017年及以后机型支持Sidebar功能。若机型为Unknown，可用搜索引擎搜索其代码以确认机型。

```
cd /tmp && curl -s https://raw.githubusercontent.com/Piker-Alpha/freqVectorsEdit.sh/master/freqVectorsEdit.sh > /tmp/freqVectorsEdit.sh && chmod +x freqVectorsEdit.sh && /tmp/freqVectorsEdit.sh && sudo rm -rf /tmp/freqVectorsEdit.sh && sudo rm -rf /tmp/Mac-*.bin
```

#### GPU

Mac Mini为移动端硬件，与台式机硬件不匹配。

由于Apple总是假设当SMBIOS存在dGPU时，所有显示输出都将通过dGPU路由，因此若Optimus笔记本电脑的外部显示器通过iGPU连接，将可能出现黑屏问题。

对于没有iGPU的CPU，若SMBIOS需要iGPU（如iMac），则Quicklook等功能将被破坏。可使用iMac Pro或Mac Pro替代iMac。

iMacPro1,1和MacPro7,1是仅有的2个允许dGPU处理所有工作负载的SMBIOS，需要Polaris、Vega或Navi GPU。

iMac20,2仅适用于Apple的定制i9-10910 CPU。

除非运行没有内置显示器的移动硬件，否则应避免使用MacMini SMBIOS，除了Intel NUC。

#### 操作系统支持

Mac可能仍然支持CPU，但不再支持那个时代的SMBIOS。如Arrandale，但在10.13.6之后没有iGPU支持。

### 配置

在进行之前通过以下命令清除旧配置。

```
bash
sudo rm -rf ~/Library/Caches/com.apple.iCloudHelper*
sudo rm -rf ~/Library/Caches/com.apple.Messages*
sudo rm -rf ~/Library/Caches/com.apple.imfoundation.IMRemoteURLConnectionAgent*
sudo rm -rf ~/Library/Preferences/com.apple.iChat*
sudo rm -rf ~/Library/Preferences/com.apple.icloud*
sudo rm -rf ~/Library/Preferences/com.apple.imagent*
sudo rm -rf ~/Library/Preferences/com.apple.imessage*
sudo rm -rf ~/Library/Preferences/com.apple.imservice*
sudo rm -rf ~/Library/Preferences/com.apple.ids.service*
sudo rm -rf ~/Library/Preferences/com.apple.madrid.plist*
sudo rm -rf ~/Library/Preferences/com.apple.imessage.bag.plist*
sudo rm -rf ~/Library/Preferences/com.apple.identityserviced*
sudo rm -rf ~/Library/Preferences/com.apple.ids.service*
sudo rm -rf ~/Library/Preferences/com.apple.security*
sudo rm -rf ~/Library/Messages
```

正常登录iCloud等苹果服务，需本机的NVRAM正常工作。部分主板需Clover的Drivers64UEFI文件夹中有`EmuVariableUefi-64.efi`才可使NVRAM正常工作。

打开Clover的config.plist，选择左侧SMBIOS，使用右侧上下箭头选择上面所确定的机型。也可通过GenSMBIOS生成SMBIOS。

```
https://github.com/corpnewt/GenSMBIOS
```

前往以下网站（需要翻墙环境），复制Clover中的Serial Number到文本框进行查询。若出现具体机型，则说明此序列号可用。若提示无效，则此序列码不可使用，需点击Generate New生成新的Serial Number。

```
https://everymac.com/ultimate-mac-lookup/ 
```

前往以下Apple官网查询序列号。如果显示有购买日期和机型等保修信息，则此序列码不可使用，需返回Clover生成新的Serial Number。直到出现提示`很抱歉，这个序列号无效。请检查您的信息并再试一次`，则可使用。

```
https://checkcoverage.apple.com/cn/zh
```

点击左侧System Parameters，生成一个UUID，系统生成或随机生成都可以，并勾选Inject System ID。复制生成的UUID到SMBIOS的SmUUID里，复制SMBIOS里的Board Serial Numbe到Rt VariablesMLB里。点击获取ROM，确保下方三码正常匹配，退出并重启。

重启后打开Hackintool，转到工具选项卡，点击Intel图标，在工具输出中查看enableHWP的值，若为1则已成功开启HWP。同时，iCloud、iMassage、FaceTime应已可正常登录。

若出现问题，可打开iMessageDebug提取Mac的三码，查看MLB和ROM是否正常显示。若为Failed，则应在Clover中加上EmuVariableUefi-64.efi。若正常显示，可把结果保存，重启电脑后再打开iMessageDebug，若两次结果一致，则黑苹果已成功洗白。

## CPU与电源管理

<details>
<summary>【进阶】Power Management State</summary>

通常为0。X86PlatformPlugin.kext能读取的已知bit如下。

|    bit     |                含义                |                   说明                  |
|------------|------------------------------------|-----------------------------------------|
| 0x00000001 | PWROK事件导致关机                  | 与GEN_PMCON_2 bit 0含义相同             |
| 0x00000002 | SYS_PWROK事件导致关机              | 与GEN_PMCON_2 bit 1含义相同             |
| 0x00000004 | THRMTRIP#事件导致关机              | 与GEN_PMCON_2 bit 3含义相同             |
| 0x00000008 | SYS_RESET#事件导致重启             | 与GEN_PMCON_2 bit 4含义相同             |
| 0x00000010 | 电源失败                           | 与GEN_PMCON_3 bit 1 PWR_FLR含义相同     |
| 0x00000020 | RTC电源丢失                        | 与GEN_PMCON_3 bit 2 RTC_PWR_STS含义相同 |
| 0x00000040 | 一般重置状态                       | 与GEN_PMCON_3 bit 9 GEN_RST_STS含义相同 |
| 0xffffff80 | SUS电源丢失                        | 与GEN_PMCON_3 bit 14含义相同            |
| 0x00010000 | ME唤醒事件导致唤醒                 | 与PRSTS bit 0 ME_WAKE_STS含义相同       |
| 0x00020000 | ME引发事件导致冷重启               | 与PRSTS bit 1 ME_HRST_COLD_STS含义相同  |
| 0x00040000 | ME引发事件导致热重启               | 与PRSTS bit 2 ME_HRST_WARM_STS含义相同  |
| 0x00080000 | ME引发事件导致关机                 | 与PRSTS bit 3 ME_HOST_PWRDN含义相同     |
| 0x00100000 | 全局重置Watchdog计时器事件         | 与PRSTS bit 6含义相同                   |
| 0x00200000 | 全局重置电源管理Watchdog计时器事件 | 与PRSTS bit 15含义相同                  |
</details>

### 原生电源管理

正常休眠需要启用原生电源管理，未启用时无法正确休眠。

#### 启用

对于Haswell和更新的消费级Sandy/Ivy Bridge，可通过启用XCPM内核的方式实现启用原生电源管理。打开IORegistryExplorer并查找AppleACPICPU，若其下附有X86PlatformPlugin，证明原生电源管理已经启用。

由于Sierra放弃了对Ivy Bridge和Ivy Bridge-E的XCPM支持，因此XCPM方法仅在10.8.5-10.11.6之间受支持。较新的操作系统将需要ssdtPRgen方法。

确保在BIOS下开启以下设置。

|          选项         |  设置  |
|-----------------------|--------|
| C States              | True   |
| P States Coordination | SW_ALL |

<details>
<summary>【注意】AMD CPU</summary>

对于AMD CPU，可使用SMCAMDProcessor，链接如下。注意需要在VirtualSMC之后加载。

```
https://github.com/trulyspinach/SMCAMDProcessor
```
</details>

##### 通过XCPM

<details>
<summary>【注意】旧版操作系统</summary>

要在较旧的操作系统（10.11及更早版本）中启用XCPM，只需在引导参数添加`-xcpm`，无需进行以下操作。
</details>

打开MaciASL，复制以下链接下的内容，另存为SSDT-PLUG.aml，并放置到Clover的ACPI/patched下即可。

```
https://github.com/acidanthera/OpenCorePkg/blob/master/Docs/AcpiSamples/Source/SSDT-PLUG.dsl
```

也可对以上SSDT进行清理。在DSDT中搜索Processor，查看第一个处理器的名称。以`SB.PR00`为例，在SSDT中删除除SB.PR00意外以外的条目即可，最后应保留一个External、一个Method、一个If。

<details>
<summary>【旧版】Haswell-E和Broadwell-E</summary>

XCPM不支持Haswell-E和Broadwell-E，但可通过设置Fake CPUID的方式实现。

对于OpenCore，在Kernel-Emulate使用以下补丁。

```
# Haswell-E
Cpuid1Data: C3060300 00000000 00000000 00000000
Cpuid1Mask: FFFFFFFF 00000000 00000000 00000000

# Broadwell-E
Cpuid1Data: D4060300 00000000 00000000 00000000
Cpuid1Mask: FFFFFFFF 00000000 00000000 00000000
```
</details>

##### 通过ssdtPRgen

在Sandy Bridge和Ivy Bridge采用新版系统（10.8.2及以上）时使用。也可用于Core 2、Haswell、Nehalem或Westmere。

对于Haswell，需要将SMBIOS设置为iMac14,x/MacBookAir6,x/MacBookPro11,x。对于Core 2，需要将SMBIOS设置为MacPro3,1。对于Nehalem或Westmere，需要将SMBIOS设置为iMac11,x/MacBookPro6,x/MacPro5,1。对于Sandy Bridge，需要将SMBIOS设置为iMac12,x/MacMini5,x/MacBookPro8,x。对于Ivy Bridge，需要将SMBIOS设置为iMac13,x/MacMini6,x/MacBookPro9,x/MacBookPro10,x。

以OpenCore为例，在配置文件的ACPI-Delete添加以下配置，以暂时删除CpuPm和Cpu0Ist表。

|      Key       |   Type  |      Value       |
|----------------|---------|------------------|
| All            | Boolean | YES              |
| Comment        | String  | Drop CpuPm       |
| Enabled        | Boolean | YES              |
| OemTableId     | Data    | 437075506d000000 |
| TableLength    | Number  | 0                |
| TableSignature | Data    | 53534454         |

|      Key       |   Type  |      Value       |
|----------------|---------|------------------|
| All            | Boolean | YES              |
| Comment        | String  | Drop Cpu0Ist     |
| Enabled        | Boolean | YES              |
| OemTableId     | Data    | 4370753049737400 |
| TableLength    | Number  | 0                |
| TableSignature | Data    | 53534454         |

重启后使用ssdtPRGen.sh脚本，命令如下。

```
cd ~
curl -o ./ssdtPRGen.sh https://raw.githubusercontent.com/Piker-Alpha/ssdtPRGen.sh/master/ssdtPRGen.sh
chmod +x ./ssdtPRGen.sh
```

脚本仓库如下。

```
https://github.com/Piker-Alpha/ssdtPRGen.sh
```

完成后得到ssdt.aml，复制到引导器的ACPI目录并重命名为SSDT-PM.aml。重启后将以上添加的两个条目禁用即可。

<details>
<summary>【注意】对于三代/HD4000，无Ivy Bridge电源管理的处理</summary>

应使用Sandy Bridge的SMBIOS，运行Sandy Bridge电源管理。

可忽略`IOPlatformPluginUtil : getCPUIDInfo: this is an unknown CPU model 0x3a`错误消息。
</details>

若出现`ACPI Error: Method parse/execution failed [\_SB._INI] , AE_ALREADY_EXIST`错误，则需要修改SSDT格式，如下。主要修改为将Processor物体移至外置，且将所有方法移至CPU设备之内。

```
DefinitionBlock ("ssdt.aml", "SSDT", 1, "APPLE ", "CpuPm", 0x00021500)
{
    External (\_PR_.CPU0, DeviceObj) // External Processor definition
    External (\_PR_.CPU1, DeviceObj) // External Processor definition

    Scope (\_PR_.CPU0) // Processor's scope
    {
        Name (APLF, Zero)
        Name (APSN, 0x04)
        Name (APSS, Package (0x20)
        {
            /*  … */
        })

        Method (ACST, 0, NotSerialized)
        {
            /*  … */
        }

        /*  … */
    }
```

然后使用ssdtPRGen.sh脚本，同上。

对于Haswell以前，可在Clover配置文件设置KernelAndKextPatches-AppleIntelCPUPM=true。有可能需要删除OEM表，即设置ACPI-SSDT-DropOem=true，非必要不使用。

对于Haswell及以后，可在Clover的配置文件中设置ACPI-SSDT-Generate-PluginType=true，以及KernelAndKextPatches-KernelLapic=true。也可使用OC-Little中的X86注入，链接如下。

```
https://github.com/daliansky/OC-little/tree/master/05-%E6%B3%A8%E5%85%A5%E8%AE%BE%E5%A4%87/05-1-%E6%B3%A8%E5%85%A5X86
```

对于AMD Radeon笔记本，可能需要删除MCFG表，通过Clover配置文件的ACPI-DropTables即可。

<details>
<summary>【进阶】OC对于Haswell + low-end的电源管理XCPM补丁</summary>

需要使用以下CPUID补丁以仿冒为Ivy Bridge。

```
Cpuid1Data: <A9 06 03 00 00 00 00 00 00 00 00 00 00 00 00 00>
Cpuid1Mask: <FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00>
```

对于10.11及更早版本，再在启动参数添加`-xcpm`即可。对于10.12及更高版本，则根据CPU类型选用以下补丁。

```
# 通用AVX补丁，均需使用
Base: [EMPTY]
Comment: Haswell+ low-end Celeron/Pentium cpuid_set_info_rdmsr (c) vit9696
Count: 1
Enabled: YES
Find: B9A00100000F32
Identifier: kernel
Limit: 0
Mask: [EMPTY]
MatchKernel: [EMPTY]
Replace: B9A001000031C0
ReplaceMask: [EMPTY]
Skip: 0

# 根据CPU类型选用
# _xcpm_bootstrap, Haswell+ low-end Celeron/Pentium 10.12
Base: _xcpm_bootstrap
Comment: _xcpm_bootstrap (Haswell+ low-end Celeron/Pentium) 10.12
Count: 1
Enabled: YES
Find: C4830022
Identifier: kernel
Limit: 0
Mask: FFFF00FF
MatchKernel: 16.
Replace: C6830022
ReplaceMask: FFFF00FF
Skip: 0

# _xcpm_bootstrap, Haswell+ low-end Celeron/Pentium 10.13+(10.13-10.15 at least)
Base: _xcpm_bootstrap
Comment: _xcpm_bootstrap (Haswell+ low-end Celeron/Pentium) 10.13+
Count: 1
Enabled: YES
Find: 00C43C22
Identifier: kernel
Limit: 0
Mask: 00FFFFFF
MatchKernel: 16.
Replace: 00C63C22
ReplaceMask: 00FFFFFF
Skip: 0
```

完成后还可使用性能修复补丁，注意非必要不使用。

```
# XCPM performance fix (10.8.5 - 10.13.3)
Base: [EMPTY]
Comment: XCPM performance fix (c) okrasit 10.8.5 - 10.13.3
Count: 0
Enabled: YES
Find: 89D8C1E0 08000000
Identifier: kernel
Limit: 0
Mask: FFFFFFFF FF000000
MatchKernel: [EMPTY]
Replace: B800FF00 00000000
ReplaceMask: FFFFFFFF FF000000
Skip: 0

# XCPM performance fix (10.13.4+)
Base: [EMPTY]
Comment: XCPM performance fix (c) okrasit & vit9696 10.13.4+
Count: 0
Enabled: YES
Find: C1E3084863D389D048C1EA20B99901
Identifier: kernel
Limit: 0
Mask: [EMPTY]
MatchKernel: [EMPTY]
Replace: C1E308B800FF000031D29090B99901
ReplaceMask: [EMPTY]
Skip: 0
```
</details>

#### 变频

##### 基本知识

###### LFM

即Low Frequency Mode，表示空闲时的最低值。LFM值仅适用于Broadwell和更新的SMBIOS。

可通过以下网站查看TDP-down Frequency以确定。

```
https://ark.intel.com/content/www/us/en/ark.html
```

也可使用以下值。

|                CPU次代                 | LFM值 |      说明     |
|----------------------------------------|-------|---------------|
| Broadwell+ Laptops                     | 08    | 相当于800Mhz  |
| Broadwell+ Desktops                    | 0A    | 相当于1000Mhz |
| Haswell/Broadwell HEDT/Server（如X99） | 0D    | 相当于1300Mhz |
| Skylake+ HEDT/Server（如X299）         | 0C    | 相当于1200Mhz |

###### EPP

即Energy Performance Preference，表示将CPU加速到其完整时钟的速度。EPP值仅适用于Skylake和更新的SMBIOS。

00表示最快，FF表示最慢。设置列表如下。

|    EPP    |   说明   |
|-----------|----------|
| 0x00-0x3F | 最大性能 |
| 0x40-0x7F | 平衡性能 |
| 0x80-0xBF | 平衡省电 |
| 0xC0-0xFF | 最大省电 |

###### Perf-Bias

即Performance Bias，确定CPU的期望整体性能。

##### 通过CPUFriendFriend

下载以下包，解压后运行CPUFriendFriend.command。运行完成后将获得CPUFriendDataProvider.kext和ssdt_data.aml，二者选其一放置即可。

建议放置CPUFriendDataProvider.kext。若放置ssdt_data.aml，则不再需要SSDT-PLUG。但此SSDT的设置在X99/X299等HEDT平台上已损坏。

```
https://github.com/corpnewt/CPUFriendFriend
```

<details>
<summary>【进阶】CPUFriend的注意事项</summary>

在OpenCore中无需考虑CPUFriendDataProvider的注入顺序，因为它仅为一个plist-only kext。

CPUFriend导致的唤醒问题可能是由于不正确的频率设置，需要修改生成配置以达到稳定效果。该问题主要表现为出现`Sleep Wake failure in efi`的panic。
</details>

##### 通过one-key-cpufriend

不推荐，会创建不良频率向量。

在终端下输入以下命令以执行一键CPU变频脚本。

```
bash -c "$(curl -fsSL https://raw.githubusercontent.com/stevezhengshiqi/one-key-cpufriend/master/one-key-cpufriend_cn.sh)"
```

完成后把桌面的CPUFriend.kext和CPUFriendDataProvider.kext放到Clover的kexts中即可。

##### 通过kexts

放置CPUFriend.kext即可。

```
https://github.com/acidanthera/CPUFriend
```

### 锁频

#### 通过Clover

打开Clover的配置文件，进入Cpu，开启HWPEnable和UseARTFrequency，并修改HWPValue为频率值，如i5 10400可设为002B2B2B，其中2B化为十进制为43，即4.3GHz，保存即可。

HWPValue即为CPU的IA32_HWP_REQUEST寄存器，以002B2B2B为例说明如下。

| 位置 |           说明           |
|------|--------------------------|
| 00   | 00代表高性能，94代表节能 |
| 2B   |                          |
| 2B   | 最高频率（十六进制）     |
| 2B   | 最低频率（十六进制）     |

#### 通过kexts

下载HWPEnable.kext，修改HWPEnabler.kext/Contents/Info.plist中的HWPDeaultVal为频率值，同上。修改完成后放置到引导器即可。

## 硬盘配置

不支持三星PM981/PM991、Micron 2200S、Intel 660p以及任何基于eMMC的硬盘。

Samsung 970 EVO Plus NVMe SSD可通过固件更新修复相关问题。

对于所有NVMe SSD，建议使用以下kext修复功率和能耗。

```
https://github.com/acidanthera/NVMeFix
```

### SSD开启TRIM

在终端输入以下命令以打开TRIM。

```
sudo trimforce enable
```

若执行后TRIM仍未开启，则需要通过Clover打kext补丁。打开Clover的config.plist，选择Kernel and Kext Pathches-Kext Pathches，添加以下补丁。

```
Name*: IOAHCIBlockStorage
Find*[HEX]: 4150504C452053534400 
Replace*[HEX]: 00000000000000000000 
```

### 屏蔽三星PM981 NVMe SSD

PM981可能会引起系统死机。放置以下SSDT即可。

```
DefinitionBlock ("", "SSDT", 2, "hack", "NVMe-Pcc", 0x00000000)
{
    External (_SB_.PCI0.RP09.PXSX, DeviceObj)

    Method (_SB.PCI0.RP09.PXSX._DSM, 4, NotSerialized)
    {
        If (!Arg2)
        {
            Return (Buffer (One)
            {
                 0x03
            })
        }

        Return (Package (0x02)
        {
            "class-code", 
            Buffer (0x04)
            {
                 0xFF, 0x08, 0x01, 0x00
            }
        })
    }
}
```

## 睡眠相关

### 打开

在终端输入以下命令，可打开Clover为黑苹果修补的休眠功能。

```
sudo pmset -a hibernatemode 29（或21）
```

在Clover的kexts文件夹放置HibernationFixup.kext，并在启动参数中加`-hbfxbeta`，即可实现hibernatemode 3休眠，下载链接如下。

```
https://github.com/acidanthera/HibernationFixup
```

### 关闭

黑苹果不支持挂起到磁盘的休眠或S4睡眠。

首先需要打开Clover配置文件，将NeverHibernate设置为true，并添加启动参数`swd_panic=1`，以避免进入睡眠后重启的问题，并给出相应的panic日志。然后在终端输入以下命令以禁止。

<details>
<summary>【进阶】对于OpenCore</summary>

还需在配置文件中设置Misc-Boot-HibernateMode为None，以避免S4睡眠。
</details>

```
# 设置睡眠模式为3
sudo pmset -a hibernatemode 0

# 禁用自动关机（一种休眠形式）
sudo pmset -a autopoweroff 0

# 禁用powernap（定期唤醒机器以保持网络和进行更新）
sudo pmset -a powernap 0

# 禁用待机
sudo pmset -a standby 0

# 禁用从iPhone/Watch唤醒
# 解决合盖后遇到偶发性的随机唤醒，如Thinkpad合盖后A面红色指示灯开始闪烁（表示设备已经睡眠），但一会以后指示灯进入常亮，而开盖屏幕不会点亮
sudo pmset -a proximitywake 0

# 禁用TCP Keep Alive机制
# 以防止每2小时唤醒一次
sudo pmset -a tcpkeepalive 0

# 删除睡眠映像并防止再次生成
sudo rm /var/vm/sleepimage
sudo mkdir /var/vm/sleepimage
```

以上终端操作也可由Hackintool完成。在Hackintool里切换到`电源`选项卡，点击最下方的齿轮按钮即可。

### 修复

若睡眠后无法唤醒，如合盖后系统死机，则可能是设备不正确导致。因为当设备收到S3调用（或S0用于唤醒）时，驱动程序需要关闭设备电源并进入低状态模式（唤醒时反之亦然）。当此类设备不与驱动程序配合，就会出现问题。

首先需要关闭睡眠，放置HibernationFixup，并按以下配置BIOS。

|           选项          |   配置   |                             说明                             |
|-------------------------|----------|--------------------------------------------------------------|
| Wake on LAN             | Disabled |                                                              |
| Trusted Platform Module | Disabled | 若在Windows中使用BitLocker，禁用此功能将导致所有加密密钥丢失 |
| Wake on USB             | Disabled | 大多数主板会通过该功能执行随机唤醒                           |
| Wake on Bluetooth       | Disabled | 需要使用蓝牙设备唤醒（如键盘）则可开启                       |

设置Clover配置文件的FixDSDTMask=0x30DF可能会解决问题。

#### 网卡检查

检查系统是否有两个有线网卡，一般为NullEthernet与有线网卡驱动共同使用造成的。若是，则删除NullEthernet后查看是否已经恢复正常。

#### 显卡检查

检查显卡驱动是否正常、注入EDID并开启Hidpi。可能需要禁用独显。

也可能是背光设置不正确，更换SSDT-PNLF即可。也可能是合盖唤醒检测损坏，在终端输入以下命令禁用即可。

```
sudo pmset lidwake 0
```

也可能是PS2键盘在唤醒时发送了垃圾内容，导致唤醒错误。使用 SSDT-HP-FixLidSleep，并将ACPI路径修改为键盘路径即可。

```
https://github.com/acidanthera/VoodooPS2/blob/master/Docs/ACPI/SSDT-HP-FixLidSleep.dsl
```

#### 声卡检查

错误的音频设备也可能会导致睡眠问题。

#### SMBus检查

SMBus未正确加载将可能导致睡眠问题。

#### TSC检查

TSC（Time Stamp Counter，时间戳计数器）确保硬件以正确速度运行，某些固件可能不会将TSC写入内核的某部分而出现问题。TSC出错时常伴随登录界面输入密码后立即卡住冻结的错误，也会导致屏幕残影。

对于笔记本电脑，可直接使用CpuTscSync。CpuTscSync结合了VoodooTSCSync的功能并在TSC不同步的情况下禁用xcpm_urgency。

```
https://github.com/acidanthera/CpuTscSync
```

对于大多数HEDT硬件，可使用VoodooTSCSync。VoodooTSCSync校正华硕HEDT/Server主板上的TSC，改善时间、音频和视频的同步。

```
https://bitbucket.org/RehabMan/VoodooTSCSync/downloads/
https://github.com/IOIIIO/AMDVanilla/raw/master/files/VoodooTSCSyncAMD.zip
```

打开终端并输入以下命令，记录输出。

```
echo $(($(sysctl -n hw.ncpu) - 1))
```

在kext上右键点击显示包内容，打开Contents/Info.plist，搜索`#CORE`并替换为刚才所得的值，保存即可使用该kext。

放置VoodooTSCSync后还需要放置TSCAdjustReset。下载后在kext上右键点击显示包内容，打开Contents/Info.plist，将IOKitPersonalities-IOPropertyMatch-IOCPUNumber更改为从0开始的CPU线程数，保存即可使用该kext。

```
https://github.com/khronokernel/Opencore-Vanilla-Desktop-Guide/blob/master/extra-files/TSCAdjustReset.kext.zip
```

#### RTC检查

RTC可能被禁用，或RTC与系统不兼容。可尝试在Clover的配置文件勾选FixRTC。

对于第一个问题，可使用SSDT-AWAC或SSDT-RTC0-RANGE-HEDT，如下。

```
# SSDT-AWAC
# 适用于大多数主板
https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-AWAC.aml

# SSDT-RTC0-RANGE-HEDT
# 适用于Intel的X99和X299平台
https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-RTC0-RANGE-HEDT.aml
```

对于第二个问题，一般会在启动时出现`BIOS Restarted in Safemode`错误。

对于OpenCore，可在配置文件开启DisableRtcChecksum以防止写入主校验和（0x58-0x59）。

然后设置UEFI-ProtoclOverride-AppleRtcRam和NVRAM-Add-rtc-blacklist，将某些区域列入黑名单。

同时需要使用RTCMemoryFixup，添加`rtcfx_exclude=`启动参数，将某些区域列入黑名单。该参数的范围为0x00-0xFF，其中0x00-0x0D的偏移不会引起任何冲突，0x80-0xAB的偏移用于存储休眠信息（IOHibernateRTCVariables），0xB0-0xB4的偏移用于PowerManagement功能。

RTCMemoryFixup下载链接如下。

```
https://github.com/acidanthera/RTCMemoryFixup
```

<details>
<summary>【旧版】对于Z68主板</summary>

可能需要修复DSDT。打开DSDT并查找RTC设备，然后替换为以下内容，保存后放置到引导器的ACPI目录。

```
Device (RTC)
{
    Name (_HID, EisaId ("PNP0B00"))  // _HID: Hardware ID
    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
    {
        IO (Decode16,
            0x0070,             // Range Minimum
            0x0070,             // Range Maximum
            0x00,               // Alignment
            0x02,               // Length
            )
    })
}
```
</details>

#### NVMe检查

检查NVMe是否已经完成修复。

#### CPU电源管理检查

检查CPU电源管理是否正常工作。

#### Thunderbolt检查

可在BIOS禁用Thunderbolt 3，以保证Thunderbolt与睡眠可同时工作。

或尝试修补Thunderbolt。

```
https://osy.gitbook.io/hac-mini-guide/details/thunderbolt-3-fix/
https://github.com/osy/ThunderboltReset
https://github.com/al3xtjames/ThunderboltPkg
```

#### USB检查

可尝试进行USB定制。

也有可能是USB3导致的问题，向DSDT打以下补丁即可。

对于0x0d使用以下补丁。

```
#Maintained by: RehabMan for: Laptop Patches
#usb_prw_0x0d_xhc.txt

# remove _PRW methods to prevent instant wake

# delete any existing XHC1 device
into device label XHC1 name_adr 0x00140000 remove_entry;
# delete any existing USB2 device
into device label USB2 name_adr 0x001D0000 remove_entry;

# if _PRW objects are methods
into method label _PRW parent_adr 0x001D0000 remove_entry;
into method label _PRW parent_adr 0x001A0000 remove_entry;
into method label _PRW parent_adr 0x00140000 remove_entry;
into method label _PRW parent_adr 0x001B0000 remove_entry;
# some other LAN cards use 0x00190000
into method label _PRW parent_adr 0x00190000 remove_entry;

# if _PRW methods are stuffed into a separate scope
into method label _PRW parent_label _SB.PCI0.EHC1 remove_entry;
into method label _PRW parent_label _SB.PCI0.EHC2 remove_entry;
into method label _PRW parent_label _SB.PCI0.XHC remove_entry;
into method label _PRW parent_label \_SB.PCI0.EHC1 remove_entry;
into method label _PRW parent_label \_SB.PCI0.EHC2 remove_entry;
into method label _PRW parent_label \_SB.PCI0.XHC remove_entry;

# if _PRW objects are names
into device name_adr 0x001D0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x001A0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x00140000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x001B0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x00190000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
# some _PRW have three entries in the Package
into device name_adr 0x001D0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x001A0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x00140000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x001B0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x00190000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;

# seems to work better if _PRW is present, but returns 0 (original was 3) for sleep state
into device name_adr 0x001D0000 insert begin Name(_PRW, Package() { 0x0D, 0 }) end;
into device name_adr 0x001A0000 insert begin Name(_PRW, Package() { 0x0D, 0 }) end;
into device name_adr 0x00140000 insert begin Name(_PRW, Package() { 0x0D, 0 }) end;
into device name_adr 0x001B0000 insert begin Name(_PRW, Package() { 0x0D, 0 }) end;
into device name_adr 0x00190000 insert begin Name(_PRW, Package() { 0x0D, 0 }) end;

# rename XHC to XHC1
# rename is not a good idea for 10.11, maybe not for prior versions
# disabled for now

#into device label XHC set_label begin XHC1 end;
#into_all all code_regex XHC\. replaceall_matched begin XHC1. end;
#into_all all code_regex XHC_\. replaceall_matched begin XHC1. end;
#into_all all code_regex \.XHC, replaceall_matched begin .XHC1, end;

#Maintained by: RehabMan for: Laptop Patches
#usb_USB_7-series.txt

# USB property injection for 7-series boards (originally HM76)

# Insert Apple USB properties into EHC1
into method label _DSM parent_adr 0x001D0000 remove_entry;
into device name_adr 0x001D0000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    If (LEqual (Arg2, Zero)) { Return (Buffer() { 0x03 } ) }\n
    Return (Package()\n
    {\n
        "subsystem-id", Buffer() { 0x70, 0x72, 0x00, 0x00 },\n
        "subsystem-vendor-id", Buffer() { 0x86, 0x80, 0x00, 0x00 },\n
        "AAPL,current-available", 2100,\n
        "AAPL,current-extra", 2200,\n
        "AAPL,current-extra-in-sleep", 1600,\n
        "AAPL,device-internal", 0x02,\n
        "AAPL,max-port-current-in-sleep", 2100,\n
    })\n
}\n
end;

# Insert Apple USB properties into EHC2
into method label _DSM parent_adr 0x001A0000 remove_entry;
into device name_adr 0x001A0000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    If (LEqual (Arg2, Zero)) { Return (Buffer() { 0x03 } ) }\n
    Return (Package()\n
    {\n
        "subsystem-id", Buffer() { 0x70, 0x72, 0x00, 0x00 },\n
        "subsystem-vendor-id", Buffer() { 0x86, 0x80, 0x00, 0x00 },\n
        "AAPL,current-available", 2100,\n
        "AAPL,current-extra", 2200,\n
        "AAPL,current-extra-in-sleep", 1600,\n
        "AAPL,device-internal", 0x02,\n
        "AAPL,max-port-current-in-sleep", 2100,\n
    })\n
}\n
end;

# Insert Apple USB properties into USB 3.0 XHC
into method label _DSM parent_adr 0x00140000 remove_entry;
into device name_adr 0x00140000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    If (LEqual (Arg2, Zero)) { Return (Buffer() { 0x03 } ) }\n
    Return (Package()\n
    {\n
        "subsystem-id", Buffer() { 0x70, 0x72, 0x00, 0x00 },\n
        "subsystem-vendor-id", Buffer() { 0x86, 0x80, 0x00, 0x00 },\n
        "AAPL,current-available", 2100,\n
        "AAPL,current-extra", 2200,\n
        "AAPL,current-extra-in-sleep", 1600,\n
        "AAPL,device-internal", 0x02,\n
        "AAPL,max-port-current-in-sleep", 2100,\n
    })\n
}\n
end;

# special cases... (not in u430 DSDT)
#into scope label _SB.PCI0.XHC.RHUB.HS05 set_label begin _SB.PCI0.XHC1.RHUB.HS05 end;
```

对于0x6d使用以下补丁。

```
#Maintained by: RehabMan for: Laptop Patches
#usb_prw_0x6d_xhc.txt

# remove _PRW methods to prevent instant wake

# delete any existing XHC1 device
into device label XHC1 name_adr 0x00140000 remove_entry;
# delete any existing USB2 device
into device label USB2 name_adr 0x001D0000 remove_entry;

# if _PRW objects are methods
into method label _PRW parent_adr 0x001D0000 remove_entry;
into method label _PRW parent_adr 0x001A0000 remove_entry;
into method label _PRW parent_adr 0x00140000 remove_entry;
into method label _PRW parent_adr 0x001B0000 remove_entry;
# some other LAN cards use 0x00190000
into method label _PRW parent_adr 0x00190000 remove_entry;

# if _PRW methods are stuffed into a separate scope
into method label _PRW parent_label _SB.PCI0.EHC1 remove_entry;
into method label _PRW parent_label _SB.PCI0.EHC2 remove_entry;
into method label _PRW parent_label _SB.PCI0.XHC remove_entry;
into method label _PRW parent_label \_SB.PCI0.EHC1 remove_entry;
into method label _PRW parent_label \_SB.PCI0.EHC2 remove_entry;
into method label _PRW parent_label \_SB.PCI0.XHC remove_entry;

# if _PRW objects are names
into device name_adr 0x001D0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x001A0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x00140000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x001B0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x00190000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\}\) remove_matched;
# some _PRW have three entries in the Package
into device name_adr 0x001D0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x001A0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x00140000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x001B0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;
into device name_adr 0x00190000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\}\) remove_matched;

# seems to work better if _PRW is present, but returns 0 (original was 3) for sleep state
into device name_adr 0x001D0000 insert begin Name(_PRW, Package() { 0x6D, 0 }) end;
into device name_adr 0x001A0000 insert begin Name(_PRW, Package() { 0x6D, 0 }) end;
into device name_adr 0x00140000 insert begin Name(_PRW, Package() { 0x6D, 0 }) end;
into device name_adr 0x001B0000 insert begin Name(_PRW, Package() { 0x6D, 0 }) end;
into device name_adr 0x00190000 insert begin Name(_PRW, Package() { 0x6D, 0 }) end;

# rename XHC to XHC1
# rename is not a good idea for 10.11, maybe not for prior versions
# disabled for now

#into device label XHC set_label begin XHC1 end;
#into_all all code_regex XHC\. replaceall_matched begin XHC1. end;
#into_all all code_regex XHC_\. replaceall_matched begin XHC1. end;
#into_all all code_regex \.XHC, replaceall_matched begin .XHC1, end;

#Maintained by: RehabMan for: Laptop Patches
#usb_USB_7-series.txt

# USB property injection for 7-series boards (originally HM76)

# Insert Apple USB properties into EHC1
into method label _DSM parent_adr 0x001D0000 remove_entry;
into device name_adr 0x001D0000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    If (LEqual (Arg2, Zero)) { Return (Buffer() { 0x03 } ) }\n
    Return (Package()\n
    {\n
        "subsystem-id", Buffer() { 0x70, 0x72, 0x00, 0x00 },\n
        "subsystem-vendor-id", Buffer() { 0x86, 0x80, 0x00, 0x00 },\n
        "AAPL,current-available", 2100,\n
        "AAPL,current-extra", 2200,\n
        "AAPL,current-extra-in-sleep", 1600,\n
        "AAPL,device-internal", 0x02,\n
        "AAPL,max-port-current-in-sleep", 2100,\n
    })\n
}\n
end;

# Insert Apple USB properties into EHC2
into method label _DSM parent_adr 0x001A0000 remove_entry;
into device name_adr 0x001A0000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    If (LEqual (Arg2, Zero)) { Return (Buffer() { 0x03 } ) }\n
    Return (Package()\n
    {\n
        "subsystem-id", Buffer() { 0x70, 0x72, 0x00, 0x00 },\n
        "subsystem-vendor-id", Buffer() { 0x86, 0x80, 0x00, 0x00 },\n
        "AAPL,current-available", 2100,\n
        "AAPL,current-extra", 2200,\n
        "AAPL,current-extra-in-sleep", 1600,\n
        "AAPL,device-internal", 0x02,\n
        "AAPL,max-port-current-in-sleep", 2100,\n
    })\n
}\n
end;

# Insert Apple USB properties into USB 3.0 XHC
into method label _DSM parent_adr 0x00140000 remove_entry;
into device name_adr 0x00140000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    If (LEqual (Arg2, Zero)) { Return (Buffer() { 0x03 } ) }\n
    Return (Package()\n
    {\n
        "subsystem-id", Buffer() { 0x70, 0x72, 0x00, 0x00 },\n
        "subsystem-vendor-id", Buffer() { 0x86, 0x80, 0x00, 0x00 },\n
        "AAPL,current-available", 2100,\n
        "AAPL,current-extra", 2200,\n
        "AAPL,current-extra-in-sleep", 1600,\n
        "AAPL,device-internal", 0x02,\n
        "AAPL,max-port-current-in-sleep", 2100,\n
    })\n
}\n
end;

# special cases... (not in u430 DSDT)
#into scope label _SB.PCI0.XHC.RHUB.HS05 set_label begin _SB.PCI0.XHC1.RHUB.HS05 end;
```

<details>
<summary>【注意】Catalina的IOClass</summary>

对于Catalina上的USB睡眠问题，可能还需要将USBMap.kext（或/System/Library/Extensions/IOUSBHostFamily.kext/Contents/PlugIns/AppleUSBHostPlatformProperties.kext/Contents/Info.plist）的IOClass由AppleUSBMergeNub修改为AppleUSBHostMergeProperties。
</details>

#### IRQ检查

IRQ问题有可能导致睡眠不正常。

### 常见问题

#### 修复休眠后摄像头失效

在终端输入以下命令即可。

```
sudo killall VDCAssistant
```

## 系统时间调整

Windows把系统硬件时间当作本地时间，即操作系统中显示的时间跟BIOS中显示的时间一致。而Linux/Mac把硬件时间当作UTC，操作系统中显示的时间是硬件时间经过换算得来的，比如说北京时间是 GMT+8，则系统中显示时间是硬件时间+8。因此两个系统的时间会出现差异。

在Windows以管理员身份打开命令提示符，输入下列命令并重启以修复两个系统时间不一致的问题。

```
Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1
```

若仍不一致，则在Windows下修改时间为自动获取，在Mac下把时区改成北京并开启自动获取，重新启动即可。

## 完成度检查

对于笔记本，可通过以下选项进行完成度检查。

### 变频测试

使用CPU-S进行变频测试，二档可用，八档以上优秀。下载链接如下。

```
http://bbs.pcbeta.com/viewthread-1698338-1-1.html
```

也可使用DPCI Manager查看。打开DPCI Manager并点击P States即可。

### 显示

分辨率和显存显示正常，支持DP、HDMI外接显示，风扇不持续高速旋转，原生亮度调节正常。

### 声音

通过VoodooHDA能有声音则可用，通过AppleALC能有声音则优秀。

### 网络

以太网需位于en0，无线支持2.4G/5G双频。支持AirDrop和Handoff则优秀。

### USB

USB接口2.0/3.0/3.1均能识别，3.0及以上接口的识别速度应有5G/s。

### 电池

系统偏好设置正常识别电池电量状态。

### 睡眠

合盖睡眠，开盖唤醒后正常点亮不黑屏。

### 输入设备

自带键盘和触摸板都能正常使用。

### 固态硬盘

打开关于本机-系统报告，检查NVMExpress和SATA/SATA Express，均显示TRIM支持已开启则优秀。

# 常见问题

## 系统安装

系统安装过程中，可通过打开安装器日志查看当前进度和所遇到的问题。

### 提示MediaKit reports not enough space on device for requested operation

EFI分区不够大。

### 安装时停在verifying installmacosx.pkg/installesd.dmg

等待一段时间后会重新启动，然后再去安装一次即可。

### 需要蓝牙连接键盘连接

主要是启动后显示鼠标和键盘的开关界面，一直循环切换。按空格即可跳过。

### 验证安装器数据时发生错误

断开网络后尝试拔掉无用外置硬盘、终端修改时间，或检查镜像是否损坏。

### 提示安装资源已过期，退出安装器以重新启动电脑，然后再次尝试

将安装U盘插入USB2.0接口，或重新制作安装盘。

### 安装卡在第一次走条的最后两分钟很久，而后提示安装器资源损坏

内存驱动问题。

### 安装时提示找不到安装器资源

可能是安装器损坏。若不行，则删除EmuVariableUefi.efi。也有可能是SMBIOS设置错误。

## 引导启动

### 安装完成后无法进入BIOS

出现了不正确的引导项。在Windows下可通过EasyUEFI删除多余的引导项，在Mac下可重置NVRAM。

### Clover提示Invalid Signature...

需要在BIOS关闭安全启动。

### Clover提示X64 Exception Error

Drivers中的驱动太新，删除或更换为旧版即可。如将PartitionDxe更换为PartitionDxeLegacy。

### Clover检测不到启动项或任何HFS/APFS分区

可能是Clover版本太旧。

### 内置kexts错误导致无法进入系统

进入恢复模式后点击常用工具-终端，输入以下命令以重建缓存。也可进入单用户模式操作。

```
// MAC为系统盘卷标，需根据情况替换
rm -rf [错误的kexts路径]
rm -rf /Volumes/MAC/System/Library/Caches/com.apple.kext.caches/Startup/kernelcache
rm -rf /Volumes/MAC/System/Library/PrelinkedKernels/prelinkedkernel
touch /Volumes/MAC/System/Library/Extensions/ && kextcache -u /Volumes/MAC
```

### 无法更改启动路径

在某些情况下，电脑的启动路径被硬编码为启动`EFI/Microsoft/Boot/bootmgfw.efi`而不是`EFI/BOOT/BOOTX64.EFI`，这将导致计算机启动系统的锁定。若遇到以上情况，则需将EFI分区里的EFI/Microsoft/Boot/bootmgfw.efi重命名为其他名称并将Clover的CLOVERX64.efi重命名为bootmgfw.efi，复制替换即可。注意，Windows的每次更新都会覆盖bootmgfw.efi，因此需要重新操作。

### 抹盘时提示MediaKit报告设备上的空间不足以执行请求的操作，或磁盘工具自动退出

根本原因是EFI分区小于200MB。

### 出现Welcome to Clover xxxx user settings卡住不动

更换版本即可。

### 提示This version of Mac OS X is not supported on this platform

更改SMBIOS即可。

### 卡在Clover引导界面不动

在引导器目录把无用的plist删除，仅保留config.plist。

### 运行后导致CMOS重置

对于Clover，可在配置文件中勾选Apple RTC，以防止CMOS重置与有关AppleALC的错误。

## 啰嗦模式

### 提示Panic

内核恐慌。可先尝试加-x参数后再次启动，若无效则应当根据错误提示选择以下的解决方案。

#### AppleIntelCPUPowerManagement/AppleRTC

Mac的CPU电源管理不起作用。

在Clover加入NullCPUPowerManagement.kext，或删除SLE下的AppleIntelCPUPowerManagement.kext和AppleIntelCPUPowerManagementClient.kext。

#### AppleTyMCEDriver

删除AppleTyMCEDriver.kext即可，可能在SLE或引导器目录。或SMBIOS不要设置MacPro4,1/MacPro5,1/Xserve3,1。

#### VoodooHDA

删除VoodooHDA.kext即可，可能在SLE或引导器目录。

#### ApplePolicyControl

删除AppleGraphicsControl.kext中的Contents/Plugins/ApplePolicyControl.kext即可。

#### Local APIC

可能是因为Mac不支持当前CPU。可尝试使用cpus=1启动标志。

#### Unable to find driver for this platform: \"ACPI\

在极少数情况下，这种恐慌只会在AppleACPIPlatform.kext损坏时发生。可尝试启动安全模式。

#### Thread 14 crash

可尝试将BIOS降级。

#### VTDecoderXPCServ

在Clover引导界面中选择Graphics Injector，勾选Inject Intel，并将*-platform-id修改为0x3E9B0000。

#### IOATAFamily

可尝试删除SLE下的IOATAFamily.kext。

### 卡在PCI configuration begin

可尝试添加启动参数npci=0x2000或npci=0x3000。两者不要同时使用。

### Still waiting for root device并禁行

表示系统无法找到系统盘，一般分为USB引导和SATA硬盘引导两种情况。更新引导器到最新版本，若无效则按照以下内容修复。

如果是USB引导，代表系统无法识别到USB，可在引导器的kexts下放置USBInjectAll.kext，也可尝试在Clover的config.plist中勾选FixOwnership。也可尝试插入USB 2.0端口而非3.0端口。启动后应当通过USB端口定制解决该问题。

如果是SATA硬盘引导，代表Mac不支持该SATA控制器。由于Mac不能正确支持RAID、IDE和RST，因此需要在BIOS将SATA设置为AHCI模式，或使用AHCI补丁。若不起作用，则可尝试在引导器的kexts部分放置以下kext，注意不要同时使用。

```
# SATA-unsupported.kext
https://github.com/khronokernel/Legacy-Kexts/blob/master/Injectors/Zip/SATA-unsupported.kext.zip

# AHCIPortInjector.kext
https://www.insanelymac.com/forum/files/file/436-ahciportinjectorkext/

# ATAPortInjector.kext
https://github.com/khronokernel/Legacy-Kexts/blob/master/Injectors/Zip/ATAPortInjector.kext.zip

# AppleAHCIPort.kext（从Catalina提取，主要用于Big Sur）
https://github.com/dortania/OpenCore-Install-Guide/blob/master/extra-files/CtlnaAHCIPort.kext.zip
```

<details>
<summary>【进阶】OC引导</summary>

可尝试打开RealeasUSBOwnership、XhciPortlimit。
</details>

### 卡在ApplelIntelLpssI2CController

在主机Windows下把SLE下的AppleInteLpssI2CController.kext删掉。若无效，再删AppleIntelLpssI2C.kext。

或者在Clover配置中禁用。打开Clover的config.plist，在KextsToPatch加入以下配置即可。

```
Name: com.apple.driver.AppleIntelLpssI2C
Find: 494F4B69 74
Replace: 494F4B69 73
Comments: Prevent Apple I2C kexts from attaching to I2C controllers, credit CoolStar
InfoPlistPatch: true

Name: com.apple.driver.AppleIntelLpssI2CController
Find: 494F4B69 74
Replace: 494F4B69 73
Comments: Prevent Apple I2C kexts from attaching to I2C controllers, credit CoolStar
InfoPlistPatch: true
```

### 卡在IOConsoleUsers:gIOScreenLockState 3或出现Busy Timeout或[IGPU] Hash data from ME never returned, status =1, doing retry

此错误是由于显卡驱动问题。如果为双显卡，需屏蔽独显，驱动集显。

更新Whatevergreen和Lilu。若无效，则在Clover主页面中选择Options，点击Graphics injector，取消勾选`InjectIntel`并把`platform-id`修改为`0×12345678`，然后启动系统。若无效，则将LE下所有kexts备份并删除，再次启动。

若仍无效，则找到SLE下AppleIntel/AMD/ATI/Ge/NVD开头的所有显卡kexts，并将除核显外的其它所有kexts备份后删除。假设为Intel核显，则删除除AppleIntel开头外的其余所有显卡kexts。

也可尝试关闭CSM，或强制PCIe 3.0链接速度，或添加启动参数agdpmod=pikera。

### 卡在IOBluetoothHCIController

真正的问题可能与蓝牙无关，而是在显卡。解决方法同上。

### 显示This version of Mac OS X is not supported on this platform!

Clover添加启动参数`-no_compat_check`，或更换SMBIOS。若不行，则换用其他版本的系统镜像。

### 卡在Service only ran for 0 seconds. Pushing respawn out by 10 second

使用SSDT而非DSDT进行独显屏蔽即可。

### 卡在Attempting system restart...MACH Reboot

在Clover的config.plist配置文件DropTables下添加以下内容。

| Signature | Type/key | String |
|-----------|----------|--------|
| MATS      |          |        |
| DMAR      |          |        |
| BGRT      |          |        |

### 卡在Welcome to Clover xxxx user settings

Clover的config.plist不适合该系统，替换即可。

### 卡在ACPI:System State [S0 S3 S4 S5] (S3)

显卡无解，可能需要外接显卡。

### 卡在apfs_module_start或VoodooPS2Controller，或安装时键盘无法使用

删除VoodooPS2Controller.kext，替换为AppleACPIPS2Nub.kext和ApplePS2Controller.kext。

### 显示DSMOS has arrived后重启

显卡问题，添加启动参数nv_disable=1禁用独显即可。若无效。可到SLE下删除所有显卡kexts。

### 出现DSMOS错误

FakeSMC.kext与dsmos.kext同时使用导致。删除dsmos.kext并使用FakeSMC.kext。

### 出现ATIRadeonX2000/ATIRadeonX3000错误

删除SLE下ATI开头的显卡驱动。

### 出现CHUDKernLib错误

Xcode用于调试核心的驱动。删除SLE下的CHUDKernLib.kext即可。

### 出现FakeSMC错误

替换一个不同版本的FakeSMC.kext即可。

### 停在FakeSMC

可能是USB问题。可关闭BIOS中的USB Legacy Support。

### 出现FakeSMCRadeon错误

替换一个不同版本的FakeSMC.kext，或删除FakeSMC.kext中的Contents/PlugIns/FakeSMCRadeon.kext即可。

### 出现ElliottForceLegacyRTC错误

删除ElliottForceLegacyRTC.kext并使用LegacyAppleRTC.kext。

### 出现AppleRTL8169Ethernet错误

删除IONetworkingFamily.kext，或IONetworkingFamily.kext下的Contents/PlugIns/AppleRTL8169Ethernet.kext。

### 出现AppleRTC错误

放入NullCPUPowerManagement.kext。或删除/System/Library/Extensions/AppleIntelCPUPowerManagement.kext和AppleIntelCPUPowerManagementClient.kext。

### 出现AppleFWOHCI错误

删除SLE下的IOFireWireFamily.kext/Contents/PlugIns/AppleFWOHCI.kext即可。

### 出现SleepEnabler错误

删除SleepEnabler.kext。

### 出现Trying to change a collection in the registry的OScollection.cpp错误

在BIOS开启ACPI 2.0 Support及ACPI APIC support。

### 出现failed to locate SMC driver错误

更新FakeSMC.kext即可。

### 出现ApplePolicyControl错误

删除SLE下的AppleGraphicsControl.kext/Contents/PlugIns/ApplePolicyControl.kext即可。

### 白屏且鼠标在屏幕左上角出现无限彩色风火轮

更新FakeSMC.kext即可。

### 出现IOMemoryDescriptor.cpp错误

内存读取错误。

### 发生lapic_native.c/lapic.c的Local APIC error内核错误

添加启动参数cpus=1，可能还需要busratio=16。

### 出现can't perform kext scan: no kext summary错误

尝试不使用kexts缓存。

### 发生Should have 2 threads, but only found 3 for Die 0的cpu_threads.c错误

重新提取修改正确的DSDT.aml即可。

### 发生IOAPIC: Version 0x20 Vectors 64:87错误

使用启动参数cpus=1或cpus=2，或删掉DSDT.aml即可。

### 出现NVClockX错误

删除NVClockX.kext或FakeSMC.kext/Contents/PlugIns/NVClockX.kext。

### 出现AppleIntelGMA950错误

删除SLE下的AppleIntelGMA950.kext。

### 出现GeForce7xxx错误

删除SLE下的eForce7xxx.kext。

### 出现IntelCPUMonitor错误

删除IntelCPUMonitor.kext或FakeSMC.kext/Contents/PlugIns/IntelCPUMonitor.kext。

### 出现Window Server Service only ran for 0 seconds错误

禁用独显。

### 卡在灰屏

灰屏表示FakeSMC未加载。

### 出现RTC:Only single RAM bank错误

在引导器放置RTCMemoryFixup.kext即可。

```
https://github.com/acidanthera/RTCMemoryFixup
```

### 卡在VoodooPS2Trackpad：idengtify TouchPad command failed

关闭RAID或改为其它模式。

### 出现SMCReadKeyActionError错误

禁用VT-d，或在启动参数中添加dart=0，或在Clover设置Drop DMAR。

### 在Ivy Bridge CPU出现PState Stepper错误

CPU的SSDT错误，进行原生电源管理修复即可。

### 出现AppleLMUController::smcReadKey Error:received error 0×84 when reading key 'MSLD'错误

使用了多余的SSDT。

### 出现Forcing CS_RUNTIME for entitlement：com.apple.rootless.restricted-block-devices

等待即可。

### 启用安全启动后无法启动

若安装时启用了安全启动，需要关闭安全启动后再次安装系统。

若无启用，则可启动到恢复分区并输入以下命令。注意确保未安装两个SSD，且已连接到网络。

```
# Macintosh HD为安装有Mac的分区名称
bless --folder "/Volumes/Macintosh HD/System/Library/CoreServices" --bootefi --personalize
```

## 系统运行

### 内置SATA硬盘显示为橙色图标

打开Clover的config.plist，在Kernel and kext Patches选项卡中的KextsToPatch加入以下代码即可。

```
Name: AppleAHCIPort
Find: 45787465 726E616C
Replace: 496E7465 726E616C
Comment: Define external drivers as internal to fix yellow drive icons
```

### RTC问题

打开终端并输入以下命令。

```
cat /private/var/log/system.log | grep rtc
```

输出示例如下。E00002C2即为需要屏蔽的内存位置。

```
localhost kernel[0]: Lilu:     rtc @ rtc read failure 1 bytes from 180 E00002C2
```

下载RTCmemoryfixup,并且在boot args中添加`rtcfx_exclude=10-FF`即可。其中10-FF为内存屏蔽区间，根据以上输出确定。

### 键盘/触控板不工作

可能是EC设备出现故障。对于笔记本，可关闭电脑后拔出电池，30秒后装回，重新开机。

对于ELAN触控板，在键盘不工作时可尝试按Escape。

### App Store无法登录

打开终端并输入以下命令以重置NVRAM即可。

```
sudo nvram -c
```

# 附录

## Kexts

大部分kexts可在以下网站找到。

```
# 新版kexts
https://dortania.github.io/builds/
https://kext.me/
https://bitbucket.org/RehabMan/
https://github.com/acidanthera
https://www.zdynb.cn/2020/hei-ping-guo-qu-dong.html
https://github.com/ClayMoreBoy/Hackintosh-Kext-Factory
https://github.com/corpnewt/Lilu-and-Friends

# 旧版kexts
https://github.com/khronokernel/Legacy-Kexts
https://onedrive.live.com/?authkey=%21APjCyRpzoAKp4xs&id=FE4038DA929BFB23%21455036&cid=FE4038DA929BFB23
https://olarila.com/files/
https://github.com/RehabMan/hack-tools/tree/master/kexts
```

可在终端输入以下命令查看kext支持的体系结构。其中二进制文件路径可通过在kext上右键点击显示包内容，然后在Contents/MacOS中找到。

```
lipo -archs [kext的二进制文件路径]
```

### Lilu

Lilu为其它kext提供接口支持，许多kext需要依赖Lilu才能运行。需要10.8或更高版本的系统，下载链接如下。

```
https://github.com/acidanthera/Lilu/
```

### FakeSMC包与VirtualSMC包

下载链接如下。

```
# FakeSMC包
## 主体与传感器驱动
https://bitbucket.org/RehabMan/os-x-fakesmc-kozlek/downloads/
https://github.com/CloverHackyColor/FakeSMC3_with_plugins

## 主体（32位）
https://github.com/khronokernel/Legacy-Kexts/blob/master/32Bit-only/Zip/FakeSMC-32.kext.zip?raw=true

## ACPIBatteryManager，电池驱动
https://bitbucket.org/RehabMan/os-x-acpi-battery-driver/downloads/

# VirtualSMC
## 主体、传感器与电池驱动
https://github.com/acidanthera/VirtualSMC
```

两者作用相同，均用于向macOS提供SMC信息，模拟白苹果启动环境。FakeSMC早于VirtualSMC，且已不再更新，因此推荐使用VirtualSMC替换FakeSMC。注意，使用VirtualSMC时Lilu需为最新版本，否则将无法进入系统。VirtualSMC包作用分别如下。

|      Kext名称     |                                             作用                                             |
|-------------------|----------------------------------------------------------------------------------------------|
| VirtualSMC        | 替换FakeSMC.kext，需在Clover的driver64UEFI中删除SMCHelper-64.efi并复制VirtualSMC.efi到此目录 |
| SMCProcessor      | 监控CPU温度，不适用于基于AMD CPU的系统                                                       |
| SMCSuperIO        | 监控风扇速度，不适用于基于AMD CPU的系统                                                      |
| SMCLightSensor    | 用于笔记本电脑上的环境光传感器，台式机可以忽略                                               |
| SMCDellSensors    | 对支持系统管理模式（SMM）的戴尔机器上的风扇进行更精细的监视和控制                            |
| SMCBatteryManager | 电源管理驱动，用于替换ACPIBatteryManager，台式机可以忽略                                     |

VirtualSMC需要10.8或更高版本的系统，旧版本应当使用FakeSMC。

<details>
<summary>【进阶】FakeSMC的Info.plist说明</summary>

REV表示SMC版本，以Base64表示，转换为十六进制即可，对应关系如下。

|      型号     | SMC版本 |   REV值  |
|---------------|---------|----------|
| MacPro3,1     | 1.25f4  | ASUPAAAE |
| MacPro4,1     | 1.39f5  | ATkPAAAF |
| MacPro5,1     | 1.39f11 | ATkPAAAR |
| iMac8,1       | 1.30f1  | ATAPAAAB |
| iMac9,1       | 1.45f0  | AUUPAAAA |
| iMac10,1      | 1.53f13 | AVMPAAAT |
| iMac11,1      | 1.54f36 | AVQPAAA2 |
| iMac12,1      | 1.72f5  | AXIPAAAF |
| MacBookPro5,1 | 1.33f8  | ATMPAAAI |
| MacBookPro5,1 | 1.33f8  | ATMPAAAI |
| MacBookPro6,1 | 1.58f16 | AVgPAAAW |
| MacBookPro7,1 | 1.62f6  | AWIPAAAG |
| MacBookPro8,1 | 1.68f96 | AWgPAACW |

smc-compatible的值列表如下。

|      型号     | smc-compatible值 |
|---------------|------------------|
| MacPro3,1     | smc-napa         |
| MacPro4,1     | smc-thurley      |
| MacPro5,1     | smc-thurley      |
| iMac9,1       | smc-napa         |
| iMac10,1      | smc-mcp          |
| iMac11,1      | smc-piketon      |
| iMac12,1      | smc-huronriver   |
| MacBookPro5,1 | smc-mcp          |
| MacBookPro5,5 | smc-mcp          |
| MacBookPro6,1 | smc-piketon      |
| MacBookPro7,1 | smc-mcp          |
| MacBookPro8,1 | smc-huronriver   |

tjmax表示CPU可承受的最大温度，可通过Aida64等方式查到。
</details>

### WhateverGreen

修复显卡必备驱动，适用于10.8及更新版本，下载链接如下。

```
https://github.com/acidanthera/WhateverGreen/releases
```

若未指定帧缓冲区，则默认帧缓冲区将被注入。若未设置帧缓冲区且系统具有独立显卡，则空帧缓冲区（零个控制器）将被注入。空帧缓冲区如下。

| 平台 | platform-id |
|------|-------------|
| SNB  | 0x00050000  |
| IVY  | 0x01620007  |
| HSW  | 0x04120004  |
| SKL  | 0x19120001  |
| KBL  | 0x59120003  |
| CFL  | 0x3E910003  |
| CML  | 0x9BC80003  |

在未确定帧缓冲区时，可通过启动参数`igfxframe=`进行设置，此时将忽略设备属性中的参数。

WhateverGreen中已包含以下kexts。

```
IntelGraphicsFixup
IntelGraphicsDVMTFixup
NvidiaGraphicsFixup
CoreDisplayFixup
Shiki
IntelGraphicsDVMTFixup
AzulPatcher4600
AppleBacklightFixup
EnableLidWake
NoVPAJpeg
FakePCIID
FakePCIID_Intel_HD_Graphics
FakePCIID_Intel_HDMI_Audio
```

注意需要关闭Clover的以下选项。

```
# DSDT
AddHDMI
FixDisplay
FixIntelGfx
AddIMEI
FixHDA
AddPNLF

# 显卡
UseIntelHDMI
SetIntelBacklight
SetIntelMaxBacklight

# 设备
Devices-Inject

# FakeID
IntelGFX
IMEI
ig-platform-id

# 重命名
GFX0 to IGPU
PEGP to GFX0
HECI to IMEI
MEI to IMEI
HDAS to HDEF
B0D3 to HDAU

# 启动参数
-disablegfxfirmware
-igfxnohdmi
```

<details>
<summary>【过时】IntelGraphicsDVMTFixup</summary>

macOS的启动需要DVMT大于`32MB`，否则将导致内核崩溃。DVMT的大小可在BIOS设置，若BIOS无相应选项，可通过grub中的`setup_var`修改。或者使用本kext，但仅用于macOS 10.13及以下，在macOS Mojave下不适用。

在Majove及更新系统，需在Clover的config.plist应用以下补丁以修复。或者使用Hackintool，应用补丁时勾选`DVMT 32MB 预分配`。

```
<key>Properties</key>
<dict>
    <key>PciRoot(0x0)/Pci(0x2,0x0)</key>
        <dict>
            <key>framebuffer-fbmem</key>
            <data>
            AACQAA==
            </data>
            <key>framebuffer-patch-enable</key>
            <data>
            AQAAAA==
            </data>
            <key>framebuffer-stolenmem</key>
            <data>
            AAAwAQ==
            </data>
        </dict>
</dict>
```

</details>

### VoodooI2C

VoodooI2C具有记忆性，由中断模式切换到轮询模式、在中断模式下修改有关触控板的DSDT等均不生效，需将VoodooI2C的相关驱动在Clover的kexts下删除再重新复制才能恢复初始设置。适用于10.11及以上系统，下载链接如下。

```
https://github.com/alexandred/VoodooI2C/releases
```

### NullCPUPowerManagement

AMD CPU无法使用英特尔的电源管理，因此我们需要取消它。

```
https://github.com/Goldfish64/SerialMouse/releases
```

## Windows读写HFS

### HFSExplorer

```
http://www.catacombae.org/hfsexplorer/
```

### HFS+ driver

```
https://forums.macrumors.com/threads/apple-hfs-windows-driver-download.1368010/
```

## UEFI驱动

### EmuVariableUefi

用于模拟NVRAM，从而将黑苹果洗白。若主板有原生NVARM，则无需放置。

### ApfsDriverLoader

APFS驱动。

```
https://github.com/acidanthera/ApfsSupportPkg
```

### HFSPlus

HFS驱动。

```
https://github.com/STLVNUB/CloverGrower/tree/master/Files/HFSPlus/x64
https://github.com/JrCs/CloverGrowerPro/tree/master/Files/HFSPlus/X64
```

### CrScreenshotDxe

```
https://github.com/LongSoft/CrScreenshotDxe
```

## 硬件驱动

### EMU-USB

```
https://github.com/Wouter1/EMU-driver
```

### kXAudioDriver

Windows和macOS的kX音频驱动程序。

```
https://github.com/kxproject/kx-audio-driver
```

### liquid coolers

液体冷却器驱动。

```
https://github.com/liquidctl/liquidctl
```

## 黑苹果库

```
# 网站
https://images.daliansky.net/d/YmBXVA8q/blog

# FTP
主机名 / repo1.macintoshgarden.org
用户名 / macgarden
密码 / publicdl
```

## OC-little包

```
https://github.com/daliansky/OC-little

# 另附P-little包（较旧）
https://github.com/daliansky/P-little
```

## 工具

### MountEFI

挂载EFI分区。

```
https://github.com/corpnewt/MountEFI
```

### Hackintool

```
http://headsoft.com.au/download/mac/Hackintool.zip
https://github.com/headkaze/Hackintool
```

### Kext Updater

```
https://bitbucket.org/profdrluigi/kextupdater/downloads/
```

### MaciASL

```
# RehabMan版
https://bitbucket.org/RehabMan/os-x-maciasl-patchmatic/downloads/

# 最新版
https://github.com/acidanthera/MaciASL/releases
```

### IORegistryExplorer

IORegistryExplorer可用于查看硬件情况。2.1版下载链接如下。

```
https://github.com/vulgo/IORegistryExplorer
https://github.com/khronokernel/IORegistryClone
```

#### 判断设备存在情况

将左上角的模式选为`IODeviceTree`，查看左侧设备树。若显示类似为`P0P5@1C,1`，则表示存在该设备。若显示类似为`P0P5@1c0001`，且点进去后只有acpi-device与acpi-path两项，则表示不存在该设备。

#### 判断设备驱动情况

将左上角的模式选为IOService，查看左侧设备树。

若显示类似为`P0P4@1C`且可展开，展开后可查看相应kexts，则该设备已驱动。部分设备可能无法展开，但也已经被驱动，如Memory Controller Hub、SMBus Controller。

若显示类似为`pci8086,266a@1F,3`，则该设备未驱动。

#### 查看CPU变频档次

搜索ACPI_SMC_PlatformPlugin，查看其中的PerformanceStateArray即可。

### gfxutil

```
https://github.com/acidanthera/gfxutil
```

### iMessageDebug

```
https://github.com/YCSuperM/ImessageDebug
```

### Clover Configurator

```
https://mackie100projects.altervista.org/download-clover-configurator/
```

### Kext Utility

```
https://en.freedownloadmanager.org/Mac-OS/Kext-Utility-FREE.html
```

### 7z

```
http://www.7-zip.org/download.html
```

### AW EDID Editor

```
https://www.analogway.com/apac/products/software-tools/aw-edid-editor/
```

### HWMonitorSMC2

监控硬件运行状况。

```
https://github.com/CloverHackyColor/HWMonitorSMC2
```

### Continuity-Activation-Tool

只能用在Broadcom无线网卡，用于启用接力功能。支持10.10-10.13。

```
https://github.com/dokterdok/Continuity-Activation-Tool
```

## 一键安装系统工具

### Ccmacos

```
http://www.ccmacos.cn/#
```

# 参考教程

## Windows下VMware Workstations Pro15.5.0安装dmg镜像

```
https://hestyle.blog.csdn.net/article/details/104672651
```

## 黑苹果必备：Intel核显platform ID整理及smbios速查表

```
https://blog.daliansky.net/Intel-core-display-platformID-finishing.html
```

## FIX BTFIRMWAREUPLOADER IN MACOS HIGH SIERRA

```
https://osxlatitude.com/forums/topic/10127-updated-nov-2017-fix-btfirmwareuploader-in-macos-high-sierra/
```

## alexandred/VoodooI2C-Gitter

```
https://gitter.im/alexandred/VoodooI2C/archives/2019/01/14
https://gitter.im/alexandred/VoodooI2C/archives/2018/08/30（搜索@Piero512）
```

## Hackintool深度教程

```
https://blog.daliansky.net/Intel-FB-Patcher-tutorial-and-insertion-pose.html
```

## 修改DSDT实现电量显示教程

```
https://www.geekcj.com/333.html
https://blog.gzxiaobai.cn/2020/05/16/%E4%B8%BA%E5%B0%8F%E7%99%BD%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%94%B5%E6%B1%A0%E6%95%99%E7%A8%8B%EF%BC%88DSDT%EF%BC%89/
```

## VoodooI2C驱动教程

```
https://www.penghubingzhou.cn/2019/01/06/VoodooI2C%20DSDT%20Edit/
https://www.penghubingzhou.cn/2019/07/24/VoodooI2C%20DSDT%20Edit%20FAQ/
https://voodooi2c.github.io/#GPIO%20Pinning/GPIO%20Pinning
```

## 英特尔®核芯显卡常见问答（WhateverGreen）

```
https://github.com/acidanthera/WhateverGreen/blob/master/Manual/FAQ.IntelHD.cn.md
```

## 黑苹果精华必读：新手常见(五国)(-v图)错误解决

```
https://www.xmyy.com/article-254928.html
```

## Disabling discrete graphics in dual-GPU laptops

```
https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/
```

## /r/Hackintosh Vanilla Desktop Guide

```
https://hackintosh.gitbook.io/-r-hackintosh-vanilla-desktop-guide/
```

## SSDT GPU (Graphics Card) Injection

```
https://www.tonymacx86.com/threads/ssdt-gpu-graphics-card-injection.183354/
```

## stevezhengshiqi/one-key-cpufriend

```
https://github.com/stevezhengshiqi/one-key-cpufriend
```

## AR9565 MAC黑苹果Bluetooth蓝牙驱动教程

```
https://www.longzc.cn/index.php/archives/308
```

## SSDT-RMNE.aml

```
https://github.com/RehabMan/OS-X-Null-Ethernet/blob/master/ssdt-rmne.aml
```

## SSDT-PNLF.aml

```
https://bitbucket.org/RehabMan/applebacklightfixup/downloads/
```

## 使用HIDPI解决睡眠唤醒黑屏、花屏及连接外部显示器的正确姿势

```
https://blog.daliansky.net/Use-HIDPI-to-solve-sleep-wake-up-black-screen,-Huaping-and-connect-the-external-monitor-the-correct-posture.html
```

## 小米笔记本Pro安装10.13随手记及EFI分享

```
https://blog.daliansky.net/XiaoMiPro-notebook-Installation-10.13-readily-remember-and-share-EFI.html
```

## Notebook Compatibility List

```
https://gpu-passthrough.com/
```

## Hackintosh won't boot? How to use verbose mode to fix it

```
http://www.macbreaker.com/2015/01/read-verbose-mode-fix-hackintosh-errors.html
```

## 新手常见(五国)(-v图)错误解决(原版,破解kernel,补丁kext下载)

```
https://blog.csdn.net/ashuai81/article/details/8032952
```

## DW1820A/BCM94350ZAE/BCM94356ZEPA50DX插入的正确姿势

```
https://blog.daliansky.net/DW1820A_BCM94350ZAE-driver-inserts-the-correct-posture.html
```

## Broadcom BCM94352z/DW1560驱动新姿势[新方法]

```
https://blog.daliansky.net/Broadcom-BCM94352z-DW1560-drive-new-posture.html
```

## OpenIntelWireless

```
https://openintelwireless.github.io/itlwm/Installation.html
```

## VoodooI2C/VoodooI2C-Patches

```
https://github.com/VoodooI2C/VoodooI2C-Patches
```

## OpenCorePkg/Kexts.md at master

```
https://github.com/acidanthera/OpenCorePkg/blob/master/Docs/Kexts.md
```

## 启用CPU-HWP, 锁定CPU最高频率, 让CPU展示其真正实力吧! (OC可用)

```
https://zhuanlan.zhihu.com/p/49183461
```

## Skylake HWP Enable

```
https://www.tonymacx86.com/threads/skylake-hwp-enable.214915/
```

## First time Hackintosh Stuck at Grey Screen after installation

```
https://www.tonymacx86.com/threads/first-time-hackintosh-stuck-at-grey-screen-after-installation.186100/
```

## Clover引导安装黑苹果卡各种问题的解决方法(内容较多)

```
https://vlambda.com/wz_7ilcImwxVbO.html
```

## El Capitan Install Demanding Bluetooth Mouse/Keyboard

```
https://www.reddit.com/r/hackintosh/comments/3v81hb/el_capitan_install_demanding_bluetooth/
```

## [CLOVER] 折腾了半天终于找到唤醒重启问题的原因了。。。

```
http://bbs.pcbeta.com/viewthread-1835747-1-1.html
```

## List of Hackintosh USB Port Limit Patches (10.15 Updated)

```
https://hackintosher.com/forums/thread/list-of-hackintosh-usb-port-limit-patches-10-15-updated.467/
```

## Wireless Buyers Guide

```
https://dortania.github.io/Wireless-Buyers-Guide/
```

## Hackintosh Internet Install Gitbook

```
https://midi1996.github.io/hackintosh-internet-install-gitbook/
```

## [Guide] Booting the OS X installer on LAPTOPS with Clover

```
https://www.tonymacx86.com/threads/guide-booting-the-os-x-installer-on-laptops-with-clover.148093/
```

## Fix incorrect time in Windows + OSX dual boot

```
https://www.tonymacx86.com/threads/fix-incorrect-time-in-windows-osx-dual-boot.133719/
```

## [教程] 【變色龍系列三】FakeSMC.kext 設定說明【08/05】

```
http://bbs.pcbeta.com/viewthread.php?tid=799385
```

## A Beginner's Guide to Creating a Custom USB SSDT

```
https://www.tonymacx86.com/threads/a-beginners-guide-to-creating-a-custom-usb-ssdt.272505/
```

## [分享] 10.11 USB问题之下篇，一步一步教你解决USB问题

```
http://bbs.pcbeta.com/viewthread-1651615-1-1.html
```

## OpenCorePkg/Docs/Kexts.md

```
https://github.com/acidanthera/OpenCorePkg/blob/master/Docs/Kexts.md
```

## DSDT笔记本电池补丁教程-让黑苹果显示电池状态信息

```
http://imacos.top/2019/12/03/1602-2/
```

## New and Improved Mac OS Tutorial, Part 1 (The Basics)

```
https://passthroughpo.st/new-and-improved-mac-os-tutorial-part-1-the-basics/
```

## 【官方双语】让任何电脑都用上黑苹果！#linus谈科技

```
https://www.bilibili.com/video/BV1vb411V7WD
```

## foxlet/macOS-Simple-KVM

```
https://github.com/foxlet/macOS-Simple-KVM
```

## Make a install USBstick, faster, better and Dualboot.

```
https://www.youtube.com/watch?v=akc1Db2KXwo
```

## Hasee macOS Library

```
https://hackintosh.kirainmoe.com/
```

## [Guide] How to patch DSDT for working battery status

```
https://www.tonymacx86.com/threads/guide-how-to-patch-dsdt-for-working-battery-status.116102/
```

## [Guide] Native Power Management for Laptops

```
https://www.tonymacx86.com/threads/guide-native-power-management-for-laptops.175801/
```

## Creating a Custom SSDT for USBInjectAll.kext

```
https://www.tonymacx86.com/threads/guide-creating-a-custom-ssdt-for-usbinjectall-kext.211311/
```

## [FIX] "Window Server Service only ran for 0 seconds" with dual-GPU

```
https://www.tonymacx86.com/threads/fix-window-server-service-only-ran-for-0-seconds-with-dual-gpu.233092/
```

## Leopard en un Raid por Software usando Chameleon

```
https://www.osx86spain.com/145/14262/leopard-en-un-raid-por-software-usando-chameleon.html
```

## ASUS 100 Series and Later Custom SSDT for XHCI USB Port Control

```
https://www.tonymacx86.com/threads/asus-100-series-and-later-custom-ssdt-for-xhci-usb-port-control.253981/
```

## [Guide] Laptop backlight control using AppleBacklightFixup.kext

```
https://www.tonymacx86.com/threads/guide-laptop-backlight-control-using-applebacklightfixup-kext.218222/
```

## Apple Backlight Injector Brightness not saved

```
https://www.tonymacx86.com/threads/apple-backlight-injector-brightness-not-saved.222952/page-14#post-1516295
```

## Install Snow Leopard on AMD PC, Laptop

```
https://geeknizer.com/install-snow-leopard-on-amd/
```

## acidanthera/bugtracker

```
https://github.com/acidanthera/bugtracker/issues/365
https://github.com/acidanthera/bugtracker/issues/1247
https://github.com/acidanthera/bugtracker/issues/1193
```

## Intel® HD Graphics

```
https://applelife.ru/threads/intel-hd-graphics.1289648/#post-595326
```

## Завод Intel® Quick Sync Video

```
https://www.applelife.ru/threads/zavod-intel-quick-sync-video.817923/page-186#post-765336
```

## dortania/bugtracker

```
https://github.com/dortania/bugtracker/issues/15
```

## macOS Big Sur 成功开启HiDPI正确姿势

```
https://juejin.cn/post/6894638510158905352
```

## Need CMOS reset after sleep, only after login

```
https://www.insanelymac.com/forum/topic/329624-need-cmos-reset-after-sleep-only-after-login/
```

## VMware15/16解鎖VMware安裝MacOS

```
https://iter01.com/557364.html
```

## 分享UltraISO，转换你的iATKOS ML2.DMG为ISO,让它支持硬盘助手写入

```
https://bbs.pcbeta.com/viewthread-1256266-1-1.html
```

## Olarila

```
https://www.olarila.com/topic/9860-guide-forcing-rgb-mode-to-fix-problems-on-external-monitors-in-macos/
https://www.olarila.com/topic/4997-usb-raise-remove-limit-port-patch-el-capitan-sierra-high-sierra-mojave-catalina/
https://www.olarila.com/topic/6451-guide-generate-ssdt-for-power-management-with-ssdtprgen/
```
